<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>蓦然回首，bug依然在灯火阑珊处</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta name="keywords" content="后端 Node.js go golang">
<meta property="og:type" content="website">
<meta property="og:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:url" content="http://yacen.github.io/page/5/index.html">
<meta property="og:site_name" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta property="og:locale" content="Zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta name="twitter:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
  
    <link rel="alternate" href="/atom.xml" title="蓦然回首，bug依然在灯火阑珊处" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蓦然回首，bug依然在灯火阑珊处</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录平时可能用到的资料</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yacen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-koa/2017-10-10-compose" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/10/koa/2017-10-10-compose/" class="article-date">
  <time datetime="2017-10-09T16:00:00.000Z" itemprop="datePublished">2017-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/10/koa/2017-10-10-compose/">koa-compose</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="compose"><a href="#compose" class="headerlink" title="compose()"></a>compose()</h2><p><code>middleware</code>里那么多的中间件，是怎么塞到<code>http</code>回调函数里面的呢？上面说是用<code>compose()</code>函数组装在一起的，怎么实现的呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断<code>middleware</code>是不是数组，不是个数组就抛错，</p>
<p>然后循环<code>middleware</code>,只要有一个元素不是<code>function</code>也抛错，</p>
<p>最后返回一个匿名函数<code>function(context,next)</code>，形成个闭包,这个匿名函数就是封装了所有<code>middleware</code>中间件函数，也就是<code>handleRequest(ctx, fnMiddleware)</code>里的<code>fnMiddleware</code>。当执行<code>fnMiddleware(ctx).then(handleResponse).catch(onerror);</code>也就执行了<code>middleware</code>里的中间件函数了。</p>
<p>执行逻辑封装在<code>dispatch (i) {...}</code>函数里，<code>index</code>是记录当前执行的中间件函数的下标。</p>
<p>首先<code>dispatch(0);</code>执行第一个 ====&gt; <code>0 &gt; -1</code>所以不会返回一个失败的<code>Promise</code> ====&gt; <code>index=0</code> ====&gt; <code>fn = middleware[i]</code> ====&gt; 两个<code>if</code>都不会执行，最后执行<code>fn</code>并返回<code>Promise</code>；执行<code>dispatch(1)</code>…<code>dispatch(2)</code>…。</p>
<p>最终<code>i===middleware.length</code>，<code>fn = next</code>，执行<code>next</code>,因为<code>fnMiddleware(ctx)</code>没有传，所以直接返回<code>return Promise.resolve()</code>,中间件执行结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/10/10/koa/2017-10-10-compose/" data-id="cjpv19ddj000qj5cprz8cl4mj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/koa/">koa</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-08-10-Docker容器的跨主机连接" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/10/docker/2017-08-10-Docker容器的跨主机连接/" class="article-date">
  <time datetime="2017-08-09T16:00:00.000Z" itemprop="datePublished">2017-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/10/docker/2017-08-10-Docker容器的跨主机连接/">Docker容器的跨主机连接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker容器的跨主机连接"><a href="#Docker容器的跨主机连接" class="headerlink" title="Docker容器的跨主机连接"></a>Docker容器的跨主机连接</h1><h2 id="使用网桥实现跨主机容器连接"><a href="#使用网桥实现跨主机容器连接" class="headerlink" title="使用网桥实现跨主机容器连接"></a>使用网桥实现跨主机容器连接</h2><p>网桥原理：网络拓扑<br><img src="./images/16.png" alt=""></p>
<h3 id="网桥实验"><a href="#网桥实验" class="headerlink" title="网桥实验"></a>网桥实验</h3><ul>
<li>两台ubuntu14.04虚拟机</li>
<li>安装网桥管理工具：<code>apt install bridge-utils</code></li>
<li>ip地址<pre><code>* Host1：10.211.55.3
* Host2: 10.211.55.5
</code></pre></li>
<li><p>网络设置</p>
<ul>
<li>修改/etc/network/interfaces 文件  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 10.211.55.3</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.211.55.1</span><br><span class="line">bridge_ports eth0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>docker设置</p>
<ul>
<li>修改/etc/default/docker 文件</li>
<li>-b 指定使用自定义网桥<ul>
<li>-b=br0</li>
</ul>
</li>
<li>–fixed-cidr限制ip地址分配范围<ul>
<li>Host1：10.211.55.64/26<ul>
<li>地址范围： 10.211.55.65~10.211.55.126</li>
</ul>
</li>
<li>Host2: 192.168.59.128/26<ul>
<li>地址范围: 10.211.55.129~10.211.55.190<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.200.1  netmask 255.255.255.0  broadcast 192.168.200.255</span><br><span class="line">        ether 02:42:c8:31:95:c9  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 39389  bytes 2838552 (2.7 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 41238  bytes 102033516 (97.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@aliyun ~]# sudo vim /etc/network/int erfaces</span><br><span class="line">        auto lo</span><br><span class="line">        iface lo inet loopback</span><br><span class="line"></span><br><span class="line">        auto br0</span><br><span class="line">        iface br0 inet static</span><br><span class="line">        address 10.211.55.3</span><br><span class="line">        netmask 255.255.255.0</span><br><span class="line">        gateway 10.211.55.1</span><br><span class="line">        bridge_ports eth0</span><br><span class="line"> </span><br><span class="line">sudo vim /etc/default/docker</span><br><span class="line">        DOCKER_OPTS=&quot; -b=br0 --fixed-cidr=&apos;10.211.55.64/26&apos;&quot;</span><br><span class="line"></span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">[root@aliyun ~]# ifconfig</span><br><span class="line">br0:...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@aliyun ~]# ips -ef | grep docker</span><br><span class="line"></span><br><span class="line">[root@aliyun ~]# idocker run -it ubuntu /bin/bash</span><br><span class="line">[root@contaner ~]ping 10.211.55.3</span><br><span class="line">[root@contaner ~]ping www.qq.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>配置简单，不依赖第三方软件<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>与主机在同网段，需要小心划分IP地址</li>
<li>需要有网段控制权，在生产环境中不易实现</li>
<li>不容易管理</li>
<li>兼容性不佳</li>
</ul>
<h2 id="使用Open-Switch实现跨主机容器连接"><a href="#使用Open-Switch实现跨主机容器连接" class="headerlink" title="使用Open Switch实现跨主机容器连接"></a>使用Open Switch实现跨主机容器连接</h2><p>Open vSwitch是哟个高质量的，多层虚拟交换机，使用开源Apache2.0许可协议，由Nicira Networks开发，主要实现代码为可移植的C代码。它的目的是让大规模网络自动化可以通过编成扩展，同时仍然支持标准的管理接口和协议</p>
<p><img src="./images/17.png" alt=""></p>
<h3 id="GRE隧道"><a href="#GRE隧道" class="headerlink" title="GRE隧道"></a>GRE隧道</h3><p>GRE：通用路由协议封装（点对点的再封装技术）</p>
<p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式</p>
<p>使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。</p>
<p>隧道协议将其他协议的数据帧或包重新封装然后通过隧道发送。</p>
<p>新的帧头提供路由信息，以便通过互联网传递被封装的负载数据</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>Virtualbox，两台ubuntu14.04虚拟机</li>
<li>双网卡，Host-Only&amp;NAT</li>
<li>安装网桥管理工具：<code>apt install bridge-utils</code></li>
<li>安装Open vswitch: <code>apt install openvswitch-switch</code></li>
<li>ip地址<pre><code>* Host1：192.168.58.103
* Host2: 192.168.58.104
</code></pre></li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>建立ovs网桥</li>
<li>添加gre连接</li>
<li>配置docker容器虚拟网桥</li>
<li>为虚拟网桥添加ovs接口</li>
<li>添加不同docker容器网段路由</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">sudo ovs-vsctl show</span><br><span class="line">sudo ovs-vsctl add-br obr0</span><br><span class="line">sudo ovs-vsctl add-port obr0 gre0</span><br><span class="line">sudo ovs-vsctl set interface gre0 type=gre options:remote_ip=192.168.59.104</span><br><span class="line">sudo ovs-vsctl show</span><br><span class="line">sudo brctl addbr bro</span><br><span class="line">sudo ifconfig br0 192.168.1.1 netmask 255.255.255.0</span><br><span class="line">sud brctl addif br0 obr0</span><br><span class="line">sudo brctl show</span><br><span class="line">sudo vim /etc/default/docker</span><br><span class="line">        DOCKER_OPTS=&quot; -b=br0&quot;</span><br></pre></td></tr></table></figure>
<h2 id="使用weave实现跨主机容器连接"><a href="#使用weave实现跨主机容器连接" class="headerlink" title="使用weave实现跨主机容器连接"></a>使用weave实现跨主机容器连接</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/08/10/docker/2017-08-10-Docker容器的跨主机连接/" data-id="cjpv19ddi000mj5cpcckgj29s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-08-05-Docker容器的数据管理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/05/docker/2017-08-05-Docker容器的数据管理/" class="article-date">
  <time datetime="2017-08-04T16:00:00.000Z" itemprop="datePublished">2017-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/05/docker/2017-08-05-Docker容器的数据管理/">Docker容器的数据管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker容器的数据管理"><a href="#Docker容器的数据管理" class="headerlink" title="Docker容器的数据管理"></a>Docker容器的数据管理</h1><h2 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h2><p>什么是数据卷（Data Volume）</p>
<ul>
<li>数据卷是经过特殊设计的目录，可以绕过联合文件（UFS），为一个或多个容器提供访问。</li>
<li>数据卷设计的目的，在于数据的永久化，它完全独立与容器的生存周期，因此，Docker不会在容器删除时删除其挂载的数据卷，也不会存在类似的垃圾搜集机制，对容器引用的数据卷进行处理。</li>
</ul>
<h2 id="数据卷架构"><a href="#数据卷架构" class="headerlink" title="数据卷架构"></a>数据卷架构</h2><p><img src="./images/12.PNG" alt="数据卷架构"></p>
<h2 id="数据卷（Data-Volume）特点"><a href="#数据卷（Data-Volume）特点" class="headerlink" title="数据卷（Data Volume）特点"></a>数据卷（Data Volume）特点</h2><ul>
<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li>
<li>数据卷可以在容器间共享和重用</li>
<li>可以对数据卷里的内容直接进行修改</li>
<li>数据卷的变化不会影响镜像的更新</li>
<li>卷会一直存在，即使挂载数据卷的容器已经被删除</li>
</ul>
<h2 id="为容器添加数据卷"><a href="#为容器添加数据卷" class="headerlink" title="为容器添加数据卷"></a>为容器添加数据卷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">[root@aliyun ~]# docker ps -al</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">6b546514f60f        ubuntu              &quot;/bin/bash&quot;         58 seconds ago      Up 57 seconds                           keen_pike</span><br><span class="line"></span><br><span class="line">[root@aliyun ~]# docker inspect 6b546514f60f</span><br><span class="line">...</span><br><span class="line">&quot;Binds&quot;: [</span><br><span class="line">    &quot;~/datavolume:/data&quot;</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="为数据卷添加访问权限"><a href="#为数据卷添加访问权限" class="headerlink" title="为数据卷添加访问权限"></a>为数据卷添加访问权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]# sudo docker run -v ~/datavolume:/data:ro -it ubuntu /bin/bash # 只读权限，在这个容器中不能创建修改文件</span><br><span class="line">root@5b888b505d84:/# touch /data/a</span><br><span class="line">touch: cannot touch &apos;/data/a&apos;: Read-only file system</span><br></pre></td></tr></table></figure>
<h2 id="使用Dockerfile构建包含数据卷的镜像"><a href="#使用Dockerfile构建包含数据卷的镜像" class="headerlink" title="使用Dockerfile构建包含数据卷的镜像"></a>使用Dockerfile构建包含数据卷的镜像</h2><p>Dockerfile指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">VOLUME [&quot;/datavolume1&quot;, &quot;/datavolume2&quot;] # 创建两个数据卷</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun docker]# mkdir volume</span><br><span class="line">[root@aliyun docker]# cd volume/</span><br><span class="line">[root@aliyun volume]# vim Dockerfile</span><br><span class="line">[root@aliyun volume]# docker build -t yacen/vol .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM ubuntu:14.04</span><br><span class="line"> ---&gt; f17b6a61de28</span><br><span class="line">Step 2/3 : VOLUME [&quot;/datavolume1&quot;, &quot;/datavolume2&quot;] # 创建两个数据卷</span><br><span class="line"> ---&gt; Running in f4ed93e68218</span><br><span class="line">Removing intermediate container f4ed93e68218</span><br><span class="line"> ---&gt; a455e7f63a57</span><br><span class="line">Step 3/3 : CMD /bin/bash</span><br><span class="line"> ---&gt; Running in ba2ea6e76631</span><br><span class="line">Removing intermediate container ba2ea6e76631</span><br><span class="line"> ---&gt; 1d40fb203767</span><br><span class="line">Successfully built 1d40fb203767</span><br><span class="line">Successfully tagged yacen/vol:latest</span><br><span class="line">[root@aliyun volume]# docker run --name vl -it yacen/vol</span><br><span class="line">root@671e8a2828a7:/# ls</span><br><span class="line">bin  boot  datavolume1  datavolume2  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@671e8a2828a7:/# [root@aliyun volume]# </span><br><span class="line">[root@aliyun volume]# docker inspect vl</span><br><span class="line">···</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;c1e3677388df79ec20c07d51b8b400446a4d402e3805adb285ed07abf5cf2b05&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/c1e3677388df79ec20c07d51b8b400446a4d402e3805adb285ed07abf5cf2b05/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/datavolume1&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;c3c65e8ac2cce78bafda904186c5cbf7ba61302b26bac2767c7eb5eb183bd9e6&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/c3c65e8ac2cce78bafda904186c5cbf7ba61302b26bac2767c7eb5eb183bd9e6/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/datavolume2&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure></p>
<h2 id="Docker的数据卷容器"><a href="#Docker的数据卷容器" class="headerlink" title="Docker的数据卷容器"></a>Docker的数据卷容器</h2><h3 id="什么是数据卷容器："><a href="#什么是数据卷容器：" class="headerlink" title="什么是数据卷容器："></a>什么是数据卷容器：</h3><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器<br><img src="./images/13.PNG" alt=""></p>
<h3 id="挂载数据卷容器的方法"><a href="#挂载数据卷容器的方法" class="headerlink" title="挂载数据卷容器的方法"></a>挂载数据卷容器的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [containerName]</span><br></pre></td></tr></table></figure>
<p>栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun _data]# docker run -it --name dvt1 yacen/vol</span><br><span class="line">root@c638ae7112ae:/# echo hello &gt; /datavolume1/hello.txt</span><br><span class="line">root@c638ae7112ae:/# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">[root@aliyun _data]# docker run -it --name dvt2 --volumes-from dvt1 ubuntu /bin/bash</span><br><span class="line">root@c0a43bf02c1d:/# ls</span><br><span class="line">bin  boot  datavolume1  datavolume2  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@c0a43bf02c1d:/# cat /datavolume1/hello.txt  </span><br><span class="line">hello</span><br><span class="line">root@c0a43bf02c1d:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@aliyun _data]# docker rm dvt1 # 如果删掉dvt1， dvt2还会有数据卷</span><br><span class="line">[root@aliyun _data]# docker rm -v dvt1 # 加上-v，dvt2还会有数据卷，因为docker会自动判断有没有容器使用这个数据卷</span><br></pre></td></tr></table></figure></p>
<h2 id="Docker数据卷的备份"><a href="#Docker数据卷的备份" class="headerlink" title="Docker数据卷的备份"></a>Docker数据卷的备份</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name] -v $&#123;pwd&#125;:/backup ubuntu tar cvf /backup/backup.tar [container data volume]</span><br></pre></td></tr></table></figure>
<p><img src="./images/14.png" alt=""></p>
<p><img src="./images/15.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from dvt1 -v ~/host/backup:/container/back --name dvt5 ubuntu tar cvf /container/dvt1.tar /datavolumes1</span><br></pre></td></tr></table></figure>
<h2 id="Docker数据卷的还原"><a href="#Docker数据卷的还原" class="headerlink" title="Docker数据卷的还原"></a>Docker数据卷的还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name] -v $&#123;pwd&#125;:/backup ubuntu tar xvf /backup/backup.tar [container data volume]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/08/05/docker/2017-08-05-Docker容器的数据管理/" data-id="cjpv19ddh000kj5cph5lq0z5p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-08-01-Docker容器的网络链接" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/01/docker/2017-08-01-Docker容器的网络链接/" class="article-date">
  <time datetime="2017-07-31T16:00:00.000Z" itemprop="datePublished">2017-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/01/docker/2017-08-01-Docker容器的网络链接/">docker容器的网络链接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker容器的网络链接"><a href="#Docker容器的网络链接" class="headerlink" title="Docker容器的网络链接"></a>Docker容器的网络链接</h1><h2 id="Docker容器的网络基础"><a href="#Docker容器的网络基础" class="headerlink" title="Docker容器的网络基础"></a>Docker容器的网络基础</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]# ifconfig</span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        ether 02:42:c8:31:95:c9  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 33851  bytes 2455629 (2.3 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 34897  bytes 86451139 (82.4 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<h3 id="docker0设备"><a href="#docker0设备" class="headerlink" title="docker0设备"></a>docker0设备</h3><p>Docker守护进程是通过docker0设备为容器进行网络连接的各种各种服务</p>
<ul>
<li>Linux的虚拟网桥<br><img src="./images/09.PNG" alt="网桥"></li>
</ul>
<h3 id="Linux的虚拟网桥的特点"><a href="#Linux的虚拟网桥的特点" class="headerlink" title="Linux的虚拟网桥的特点"></a>Linux的虚拟网桥的特点</h3><ul>
<li>可以设置IP地址</li>
<li>相当于拥有一个隐藏的虚拟网卡</li>
</ul>
<h3 id="docker0的地址划分"><a href="#docker0的地址划分" class="headerlink" title="docker0的地址划分"></a>docker0的地址划分</h3><ul>
<li>IP：172.17.42.1 子网掩码：255.255.0.0</li>
<li>MAC：02:42:ac:11:00:00到02:42:ac:11:ff:ff</li>
<li>总共有65534个地址<br><img src="./images/10.PNG" alt="网桥"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bridge-utils</span><br><span class="line">[root@aliyun ~]# brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242c83195c9	no	</span><br><span class="line">[root@aliyun ~]# docker run -it --name nwt1 ubuntu /bin/bash</span><br><span class="line">root@bc983ef8a842:/# ifconfig</span><br><span class="line">etho ....</span><br><span class="line">root@bc983ef8a842:/# [root@aliyun ~]# </span><br><span class="line">[root@aliyun ~]# </span><br><span class="line">[root@aliyun ~]# brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242c83195c9	no		veth173cfd3</span><br><span class="line">[root@aliyun ~]# ifconfig</span><br><span class="line">...</span><br><span class="line">veth173cfd3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether ca:44:eb:f3:19:e5  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 5430  bytes 455919 (445.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 6341  bytes 15582377 (14.8 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改docker0地址："><a href="#修改docker0地址：" class="headerlink" title="修改docker0地址："></a>修改docker0地址：</h3><p><code>sudo ifconfig docker0 192.168.200.1 netmask 255.255.255.0</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ~]# ifconfig docker0 192.168.200.1 netmask 255.255.255.0</span><br><span class="line">[root@aliyun ~]# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.200.1  netmask 255.255.255.0  broadcast 192.168.200.255</span><br><span class="line">        ether 02:42:c8:31:95:c9  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 39281  bytes 2835528 (2.7 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 41238  bytes 102033516 (97.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">...</span><br><span class="line"># 重启docker，容器ip也改变</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义虚拟网桥"><a href="#自定义虚拟网桥" class="headerlink" title="自定义虚拟网桥"></a>自定义虚拟网桥</h3><ol>
<li><p>添加虚拟网桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr br0</span><br><span class="line">ifconfig br0 192.168.100.1 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改docker守护进程的启动配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/default/docker中添加DOCKER_OPS值</span><br><span class="line">-b=br0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Docker容器的互联"><a href="#Docker容器的互联" class="headerlink" title="Docker容器的互联"></a>Docker容器的互联</h2><p>用户测试的Docker镜像Dockerfile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y ping</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN apt-get install -y curl</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cct &amp;&amp; cd cct</span><br><span class="line">vim Dockerfile</span><br><span class="line">docker buid -t yacen/cct .</span><br></pre></td></tr></table></figure>
<h3 id="允许所有容器互联"><a href="#允许所有容器互联" class="headerlink" title="允许所有容器互联"></a>允许所有容器互联</h3><ul>
<li>Docker默认是互相连接的<ul>
<li><code>--icc=true</code> 默认</li>
</ul>
</li>
<li>Docker服务重启时，IP地址会变<ul>
<li>加<code>--link</code> 选项解决: <code>docker run --link [CONTAINER_NAME]:[ALIAS] [IMAGE] [COMMOND]</code></li>
</ul>
</li>
</ul>
<h3 id="拒绝容器间互联"><a href="#拒绝容器间互联" class="headerlink" title="拒绝容器间互联"></a>拒绝容器间互联</h3><ul>
<li><code>--icc=false</code> </li>
</ul>
<h3 id="允许特定容器间的连接"><a href="#允许特定容器间的连接" class="headerlink" title="允许特定容器间的连接"></a>允许特定容器间的连接</h3><ul>
<li><code>--icc=false --iptables=true</code> </li>
<li><code>--link</code></li>
</ul>
<h2 id="Docker容器与外部网络的链接"><a href="#Docker容器与外部网络的链接" class="headerlink" title="Docker容器与外部网络的链接"></a>Docker容器与外部网络的链接</h2><h3 id="ip-forward"><a href="#ip-forward" class="headerlink" title="ip_forward"></a>ip_forward</h3><p>Linux系统的流量转发</p>
<ul>
<li><code>--ip-forward=true</code>守护进程配置项，使得操作系统启用流量转发<ul>
<li><code>sysctl net.ipv4.conf.all.forwarding</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ntw]# sysctl net.ipv4.conf.all.forwarding</span><br><span class="line">net.ipv4.conf.all.forwarding = 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>iptables是与Linux内核集成的包过滤防火墙系统，几乎所有的linux发行版都会包括iptables的功能<br><img src="./images/11.PNG" alt="网桥"></p>
<ul>
<li>表（table）</li>
<li>链（chain）</li>
<li>规则（rule）<ul>
<li>ACCEPT，REJECT，DROP</li>
</ul>
</li>
</ul>
<p>filter表中包含的链：</p>
<ul>
<li>INPUT</li>
<li>FORWARD</li>
<li>OUTPUT<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun ntw]# iptables -t filter -L -n</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-USER  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DOCKER-ISOLATION-STAGE-2  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="允许端口映射访问"><a href="#允许端口映射访问" class="headerlink" title="允许端口映射访问"></a>允许端口映射访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 80 --name nginxweb yacen/nginximage nginx</span><br><span class="line">docker port nginxweb</span><br></pre></td></tr></table></figure>
<h3 id="限制IP访问容器"><a href="#限制IP访问容器" class="headerlink" title="限制IP访问容器"></a>限制IP访问容器</h3><p>iptables 设置即可</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/08/01/docker/2017-08-01-Docker容器的网络链接/" data-id="cjpv19ddh000ij5cpwzek3jig" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-07-25-Docker指令" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/25/docker/2017-07-25-Docker指令/" class="article-date">
  <time datetime="2017-07-24T16:00:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/25/docker/2017-07-25-Docker指令/">Docker指令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><ul>
<li><code># Comment</code></li>
<li><code>INSTRUCTION argument</code></li>
</ul>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># First Dockerfile</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER yace &quot;yacen@gmail.com&quot;</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y nginx</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h2><ul>
<li><code>FROM &lt;image&gt;</code></li>
<li><code>FROM &lt;image&gt;:&lt;tag&gt;</code></li>
</ul>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><ul>
<li>已存在的镜像</li>
<li>基础镜像</li>
<li>必须是第一条非注释指令</li>
</ul>
<h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a><code>MAINTAINER</code></h2><ul>
<li>指定镜像的作者信息，包含镜像的所有者和联系信息</li>
<li><code>MAINTAINER &lt;namme&gt;</code></li>
</ul>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><code>RUN</code></h2><ul>
<li>指定当前镜像中运行的命令</li>
<li><code>RUN &lt;commmmand&gt;</code>(shell 模式)<ul>
<li><code>/bin/sh -c command</code></li>
</ul>
</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>(exec 模式)<ul>
<li><code>RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code></li>
</ul>
</li>
</ul>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a><code>EXPOSE</code></h2><ul>
<li>指定运行该镜像的容器使用的端口</li>
<li><code>EXPOSE &lt;port&gt;[&lt;port&gt;...]</code></li>
<li>在运行容器还需指定端口映射，这只是定义有哪些端口要暴露<ul>
<li>docker run -d –name nginxweb1 -p 32421:80 yacen/df_test nginx -g “daemon off;”</li>
</ul>
</li>
</ul>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><code>CMD</code></h2><ul>
<li>执行一个命令，在容器运行时的默认行为命令，<code>RUN</code>是镜像构建中运行</li>
<li><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>(exec 模式)</li>
<li><code>CMD commmmand param1 param2</code>(shell 模式)</li>
<li><code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code>(作为ENTRYPOINT指令的默认参数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># First Dockerfile</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER yace &quot;yacen@gmail.com&quot;</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemmon off;&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;yacen/df_test&quot; .</span><br><span class="line">docker run -d --name nginxweb1 -p 32421:80 yacen/df_test </span><br><span class="line">docker run -d --name nginxweb1 -p 32421:80 yacen/df_test /bin/bash # 这会覆盖Dockerfile的CMD 命令</span><br></pre></td></tr></table></figure>
<h2 id="ENTERYPOINT"><a href="#ENTERYPOINT" class="headerlink" title="ENTERYPOINT"></a><code>ENTERYPOINT</code></h2><ul>
<li>类似<code>CMD</code>,区别在于 ENTERYPOINT不会被<code>run</code>覆盖,但可以用<code>docker run --entrypoin</code>t 覆盖</li>
<li><code>ENTERYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>(exec 模式)</li>
<li><code>ENTERYPOINT commmmand param1 param2</code>(shell 模式)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER yace &quot;yacen@gmail.com&quot;</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTERYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line">CMD [&quot;-h&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>docker run -d --name nginxweb1 -p 32421:80 yacen/df_test -g &quot;daemmon off;&quot; # -g &quot;daemmon off;&quot;覆盖CMD</code></p>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><code>ADD</code></h2><ul>
<li><code>ADD &lt;src&gt;...&lt;dest&gt;</code></li>
<li><code>ADD [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;]</code>适用文件路径中有空格的情况</li>
</ul>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a><code>COPY</code></h2><ul>
<li><code>COPY &lt;src&gt;...&lt;dest&gt;</code></li>
<li><code>COPY [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;]</code>适用文件路径中有空格的情况</li>
</ul>
<h3 id="src主机文件，dest是容器绝对路径"><a href="#src主机文件，dest是容器绝对路径" class="headerlink" title="src主机文件，dest是容器绝对路径"></a>src主机文件，dest是容器绝对路径</h3><h2 id="ADD-vs-COPY"><a href="#ADD-vs-COPY" class="headerlink" title="ADD vs COPY"></a><code>ADD</code> vs <code>COPY</code></h2><ul>
<li><code>ADD</code>包含类似tar 的解压功能</li>
<li>如果单纯复制文件，docker推荐<code>COPY</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER yace &quot;yacen@gmail.com&quot;</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y nginx</span><br><span class="line">COPY index.html /usr/share/nginx/html</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTERYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a><code>VOLUME</code></h2><ul>
<li>向基于镜像创建的容器添加卷,</li>
<li><code>VOLUME [&quot;/data&quot;]</code></li>
</ul>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a><code>WORKDIR</code></h2><ul>
<li>设置工作目录</li>
<li><code>WORKDIR /path/to/workdir</code></li>
</ul>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a><code>ENV</code></h2><ul>
<li>设置环境变量</li>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key&gt;=&lt;value&gt;...</code></li>
</ul>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a><code>USER</code></h2><ul>
<li>镜像会以什么样的用户运行</li>
<li><code>USER daemon</code><ul>
<li><code>USER nginx</code>基于该镜像启动的容器，就会以nginx的身份运行</li>
<li><code>USER user</code></li>
<li><code>USER uid</code></li>
<li><code>USER user:group</code></li>
<li><code>USER uid:gid</code></li>
<li><code>USER user:gid</code></li>
<li><code>USER uid:group</code></li>
</ul>
</li>
</ul>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a><code>ONBUILD</code></h2><ul>
<li>为镜像添加触发器</li>
<li>当一个镜像被其他镜像作为基础镜像时执行</li>
<li>会在构建过程中插入触发器的指令</li>
<li><code>ONBUILD [INSTRUCTION]</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM yacen/df_test</span><br><span class="line">MAINTAINER yace &quot;yacen@gmail.com&quot;</span><br><span class="line">ONBUILD COPY index.html /usr/share/nginx/html</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTERYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Dockerfile-构建过程"><a href="#Dockerfile-构建过程" class="headerlink" title="Dockerfile 构建过程"></a>Dockerfile 构建过程</h2><ul>
<li>从基础镜像运行一个容器（FROM XXX）</li>
<li>执行一条指令，对容器做出修改</li>
<li>执行类似docker commit的操作，提交一个新的镜像层</li>
<li>在基于刚提交的镜像运行一个新的容器</li>
<li>执行dockerfile中的下一条指令，直至所有指令执行完毕</li>
</ul>
<h2 id="使用中间层镜像进行调试的好处"><a href="#使用中间层镜像进行调试的好处" class="headerlink" title="使用中间层镜像进行调试的好处"></a>使用中间层镜像进行调试的好处</h2><ul>
<li>查找错误</li>
</ul>
<h2 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h2><ul>
<li>有些情况不使用缓存，<ul>
<li><code>docker build -t=&quot;DockerfildDir&quot; --no-cache</code></li>
<li>dockerfile: <code>ENV REFRESH_DATE 2017-04-01</code>缓存刷新</li>
</ul>
</li>
</ul>
<h2 id="查看镜像的构建过程"><a href="#查看镜像的构建过程" class="headerlink" title="查看镜像的构建过程"></a>查看镜像的构建过程</h2><ul>
<li><code>docker history [image]</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/07/25/docker/2017-07-25-Docker指令/" data-id="cjpv19ddg000gj5cpssx65mw5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-07-20-Docker的cs模式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/20/docker/2017-07-20-Docker的cs模式/" class="article-date">
  <time datetime="2017-07-19T16:00:00.000Z" itemprop="datePublished">2017-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/20/docker/2017-07-20-Docker的cs模式/">Docker的cs模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker的c-s模式"><a href="#Docker的c-s模式" class="headerlink" title="Docker的c/s模式"></a>Docker的c/s模式</h1><p><img src="./images/06.PNG" alt="docker的c/s模式"></p>
<h2 id="Remote-API"><a href="#Remote-API" class="headerlink" title="Remote API"></a>Remote API</h2><ul>
<li>RESTfun风格API</li>
<li>STDIN,STDOUT,STDERR<br><img src="./images/07.PNG" alt="docker的c/s模式"></li>
</ul>
<h2 id="Docker官方的Remote-API-Reference"><a href="#Docker官方的Remote-API-Reference" class="headerlink" title="Docker官方的Remote API Reference"></a>Docker官方的Remote API Reference</h2><p><a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/</a></p>
<h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><ul>
<li>unix:///var/run/docker.sock</li>
<li>tcp://host:port</li>
<li>fd://socketfd<br><img src="./images/08.PNG" alt="docker的c/s模式"></li>
</ul>
<h2 id="unix-socket"><a href="#unix-socket" class="headerlink" title="unix socket"></a>unix socket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -U /var/run/docker.sock</span><br></pre></td></tr></table></figure>
<h2 id="查看守护进程"><a href="#查看守护进程" class="headerlink" title="查看守护进程"></a>查看守护进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep docker</span><br><span class="line">sudo status docker</span><br></pre></td></tr></table></figure>
<h2 id="守护进程管理"><a href="#守护进程管理" class="headerlink" title="守护进程管理"></a>守护进程管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  # 启动docker守护进程</span><br><span class="line">systemctl status docker # docker执行情况</span><br><span class="line">systemctl stop docker   # 停止docker守护进程</span><br></pre></td></tr></table></figure>
<h2 id="Docker的启动选项"><a href="#Docker的启动选项" class="headerlink" title="Docker的启动选项"></a>Docker的启动选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d [OPTIONS]</span><br></pre></td></tr></table></figure>
<ul>
<li>运行相关：<ul>
<li>-D, –debug=false </li>
<li>-e, –exec-driver=”native”</li>
<li>-g, –graph=”/var/lib/docker”</li>
<li>–icc=true</li>
<li>-l, –log-level=”info”</li>
<li>–label=[]</li>
<li>-p, –pidfile=”/var/run/docker.pid”</li>
</ul>
</li>
<li>Docker 服务链接相关：<ul>
<li>-G, –group=”docker”</li>
<li>-H, –host=[]</li>
<li>–tls=false</li>
<li>–tlscacert=”/home/sven/.docker/ca.pem”</li>
<li>–tlscert=”/home/sven/.docker/cert.pem”</li>
<li>–tlscert=”/home/sven/.docker/key.pem”</li>
<li>–tlsverify=false</li>
</ul>
</li>
<li>存储相关:<ul>
<li>-s, –storage-driver=””</li>
<li>–selinux-enabled=false</li>
<li>–storage-opt=[]</li>
</ul>
</li>
<li>Registry 相关：<ul>
<li>–insecure-registry=[]</li>
<li>–registry-mirror=[]</li>
</ul>
</li>
<li>网络设置相关：<ul>
<li>-b, –bridge=””</li>
<li>–bip=””</li>
<li>–fixed-cidr=””</li>
<li>–fixed-cidr-v6=””</li>
<li>–dns=[]</li>
<li>–dns-search=[]</li>
<li>–ip=0,0,0,0</li>
<li>–ip-forward=true</li>
<li>–ip-masq=true</li>
<li>–iptables=true</li>
<li>–ipv6=flase</li>
<li>–mtu=0</li>
</ul>
</li>
</ul>
<h2 id="启动配置文件"><a href="#启动配置文件" class="headerlink" title="启动配置文件"></a>启动配置文件</h2><ul>
<li><code>/etc/default/docker</code></li>
</ul>
<h2 id="docker的远程访问"><a href="#docker的远程访问" class="headerlink" title="docker的远程访问"></a>docker的远程访问</h2><ul>
<li>两台docker的服务器</li>
<li>修改docker守护进程启动选项，区别服务器</li>
<li>保证Client API与Server API的版本一致</li>
</ul>
<h2 id="修改服务器端配置"><a href="#修改服务器端配置" class="headerlink" title="修改服务器端配置"></a>修改服务器端配置</h2><ul>
<li><p>修改Docker守护进程启动选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   -H tcp://host:port </span><br><span class="line">      unix:///path/to/socket</span><br><span class="line">      fd://* or fd://socketfd</span><br><span class="line">```        </span><br><span class="line">* 守护进程默认配置：</span><br><span class="line">    * -H unix:///var/run/docker.sock</span><br><span class="line"></span><br><span class="line">## 修改客户端配置</span><br><span class="line">* 修改Docker客户端命名选项</span><br></pre></td></tr></table></figure>
<p> -H tcp://host:port </p>
<pre><code>unix:///path/to/socket
fd://* or fd://socketfd
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 守护进程默认配置：</span><br><span class="line">    * -H unix:///var/run/docker.sock</span><br><span class="line">* 使用环境变量Docker_HOST</span><br><span class="line">    * export DOCKER_HOST=&quot;tcp://10.211.55.5:2375&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>docker -H tcp://10.211.55.5:2375 info<br>或<br>export DOCKER_HOST=”tcp://10.211.55.5:2375”<br>docker info<br><code>`</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/07/20/docker/2017-07-20-Docker的cs模式/" data-id="cjpv19ddf000dj5cprtft4ce7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-07-15-构建镜像" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/15/docker/2017-07-15-构建镜像/" class="article-date">
  <time datetime="2017-07-14T16:00:00.000Z" itemprop="datePublished">2017-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/docker/2017-07-15-构建镜像/">构建镜像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><ul>
<li>保存对容器的修改，并在此使用</li>
<li>自定义镜像的能力</li>
<li>以软件的形式打包并分发服务及其运行环境</li>
</ul>
<h2 id="通过容器构建"><a href="#通过容器构建" class="headerlink" title="通过容器构建"></a>通过容器构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] container [repository[:TAG]]</span><br></pre></td></tr></table></figure>
<ul>
<li>-a, –author=”” 作者</li>
<li>-m, –message=”” 提交信息</li>
<li>-p, –pause=true 可以在提交时不暂停容器，默认暂停<h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br><span class="line">docker run -i -t -p :80 --name commit_test  ubuntu:14.04 /bin/bash</span><br><span class="line">apt update</span><br><span class="line">apt install nginx</span><br><span class="line">exit</span><br><span class="line">docker ps -l</span><br><span class="line">docker commit -a &apos;yacen&apos; -m &apos;firstcommit&apos; commit_test yacen/commit_test1</span><br><span class="line">docker images</span><br><span class="line">docker run -d --name nginxweb -p 32421:80 yacen/commit_test1 nginx -g &quot;daemon off;&quot;</span><br><span class="line">docker port XXX</span><br><span class="line">curl http://localhost:32421</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="通过DockerFile文件构建"><a href="#通过DockerFile文件构建" class="headerlink" title="通过DockerFile文件构建"></a>通过DockerFile文件构建</h2><ol>
<li>创建Dockerfile</li>
<li>使用<code>docker build</code>命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>–force-rm=false</li>
<li>–no-cache=false</li>
<li>–pull=false</li>
<li>-q, –quiet=false 安静，不显示log</li>
<li>–rm=true</li>
<li>-t, –tag=”” 给镜像取个名字</li>
</ul>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># First Dockerfile</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER yace &quot;yacen@gmail.com&quot;</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y nginx</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>
<h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/docker/df_test &amp;&amp; cd ~/docker/df_test</span><br><span class="line">vim Dockerfile ## 粘贴上面文本</span><br><span class="line">docker build -t=&quot;yacen/df_test&quot; .</span><br><span class="line">docker run -d --name nginxweb1 -p 32421:80 yacen/df_test nginx -g &quot;daemon off;&quot;</span><br><span class="line">docker port XXX</span><br><span class="line">curl http://localhost:32421</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/07/15/docker/2017-07-15-构建镜像/" data-id="cjpv19dde000cj5cpfr6dmty2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-07-10-获取和推送镜像" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/10/docker/2017-07-10-获取和推送镜像/" class="article-date">
  <time datetime="2017-07-09T16:00:00.000Z" itemprop="datePublished">2017-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/10/docker/2017-07-10-获取和推送镜像/">获取和推送镜像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="获取和推送镜像"><a href="#获取和推送镜像" class="headerlink" title="获取和推送镜像"></a>获取和推送镜像</h1><h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><ol>
<li>Docker Hub<ul>
<li><a href="http://registry.hub.docker.com" target="_blank" rel="noopener">http://registry.hub.docker.com</a></li>
</ul>
</li>
<li><code>docker search [OPTIONS] TERM</code><ul>
<li>–automated=false Only show automated builds</li>
<li>–no-trunc=false 不截断输出</li>
<li>-s. –stars=0 星级</li>
</ul>
</li>
</ol>
<h2 id="拉去镜像"><a href="#拉去镜像" class="headerlink" title="拉去镜像"></a>拉去镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] Name[:TAG]</span><br></pre></td></tr></table></figure>
<ul>
<li>-a, –all-tags=false 下载这个仓库中所有有标记的镜像<h3 id="使用-registry-mirror-选项"><a href="#使用-registry-mirror-选项" class="headerlink" title="使用 -registry-mirror 选项"></a>使用 -registry-mirror 选项</h3></li>
</ul>
<ol>
<li>修改： /etc/default/docker</li>
<li>添加：DOCKER_OPTIONS=”–registry-mirror=<a href="http://MIRROR&quot;" target="_blank" rel="noopener">http://MIRROR&quot;</a></li>
</ol>
<h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push NAME[:TAG]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/07/10/docker/2017-07-10-获取和推送镜像/" data-id="cjpv19ddc0009j5cp6gg42x6p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式/2017-07-05-分布式锁" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/分布式/2017-07-05-分布式锁/" class="article-date">
  <time datetime="2017-07-04T16:00:00.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/request/">request</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/分布式/2017-07-05-分布式锁/">分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁，是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p>
<h2 id="分布式锁的实现方式"><a href="#分布式锁的实现方式" class="headerlink" title="分布式锁的实现方式"></a>分布式锁的实现方式</h2><ul>
<li>基于数据库实现</li>
<li>基于Redis实现</li>
<li>基于ZooKeeper实现</li>
</ul>
<h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。</p>
<p>当我们要从数据库中读取数据的时候，同时把这个version字段也读出来，如果要对读出来的数据进行更新后写回数据库，则需要将version加1，同时将新的数据与新的version更新到数据表中，且必须在更新的时候同时检查目前数据库里version值是不是之前的那个version，如果是，则正常更新。如果不是，则更新失败，说明在这个过程中有其它的进程去更新过数据了。</p>
<p>乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p>
<p>使用「乐观锁」机制，必须得满足：</p>
<ol>
<li>锁服务要有递增的版本号version</li>
<li>每次更新数据的时候都必须先判断版本号对不对，然后再写入新的版本号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 下单减库存</span></span><br><span class="line"><span class="comment">* @param productId</span></span><br><span class="line"><span class="comment">* @return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> updateCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (updateCnt == <span class="number">0</span>) &#123;</span><br><span class="line">    ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">    <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;"</span>, productId, product.getNumber());</span><br><span class="line">      <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//卖完啦</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。</p>
<p><em>注意</em> ：UPDATE 语句的WHERE 条件字句上需要建索引</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁也叫作排它锁，在Mysql中是基于 for update 来实现加锁的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新库存(使用悲观锁)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">  <span class="comment">//先锁定商品库存记录</span></span><br><span class="line">  ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125; FOR UPDATE"</span>, productId);</span><br><span class="line">  <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">    <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a>基于Redis实现</h2><p>官方推荐采用Redlock算法，即使用string类型，加锁的时候给的一个具体的key，然后设置一个随机的值；取消锁的时候用使用lua脚本来先执行获取比较，然后再删除key。具体的命令如下：</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>
<h3 id="取消锁"><a href="#取消锁" class="headerlink" title="取消锁"></a>取消锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script 1 resource_name my_random_value</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="基于ZooKeeper实现"><a href="#基于ZooKeeper实现" class="headerlink" title="基于ZooKeeper实现"></a>基于ZooKeeper实现</h2><p>其实基于ZooKeeper，就是使用它的临时有序节点来实现的分布式锁。</p>
<p>原理就是：当某客户端要进行逻辑的加锁时，就在zookeeper上的某个指定节点的目录下，去生成一个唯一的临时有序节点， 然后判断自己是否是这些有序节点中序号最小的一个，如果是，则算是获取了锁。如果不是，则说明没有获取到锁，那么就需要在序列中找到比自己小的那个节点，并对其调用exist()方法，对其注册事件监听，当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。</p>
<p>当释放锁的时候，只需将这个临时节点删除即可。</p>
<p>具体看这篇文章<a href="https://www.jianshu.com/p/5d12a01018e1" target="_blank" rel="noopener">Zookeeper实现分布式锁</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/07/05/分布式/2017-07-05-分布式锁/" data-id="cjpv19dg1007bj5cpgfvkltwd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker/2017-07-05-查看和删除镜像" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/docker/2017-07-05-查看和删除镜像/" class="article-date">
  <time datetime="2017-07-04T16:00:00.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/docker/2017-07-05-查看和删除镜像/">查看和删除镜像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="查看和删除镜像"><a href="#查看和删除镜像" class="headerlink" title="查看和删除镜像"></a>查看和删除镜像</h1><h2 id="Docker-Image-镜像"><a href="#Docker-Image-镜像" class="headerlink" title="Docker Image 镜像"></a>Docker Image 镜像</h2><ul>
<li>容器的基石</li>
<li>层叠的只读文件系统</li>
<li>联合加载（union mount）<br><img src="./images/03.PNG" alt=""></li>
</ul>
<h2 id="镜像的存储位置"><a href="#镜像的存储位置" class="headerlink" title="镜像的存储位置"></a>镜像的存储位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>docker info</code> 查看信息</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY]</span><br><span class="line"></span><br><span class="line">docker images -a centos</span><br></pre></td></tr></table></figure>
<ul>
<li>-a, –all=false： 所有镜像，默认不显示中间层镜像</li>
<li>-f, –filter=[]：过滤条件</li>
<li>–no-trunc=false：不使用截断的形式显示数据</li>
<li>-q, –quiet=false：只显示镜像id</li>
</ul>
<h2 id="镜像的仓库"><a href="#镜像的仓库" class="headerlink" title="镜像的仓库"></a>镜像的仓库</h2><ul>
<li>REPOSITORY 仓库<br>  镜像的集合，相关联的镜像</li>
<li>REGISTRY 仓库？</li>
</ul>
<h2 id="镜像的标签"><a href="#镜像的标签" class="headerlink" title="镜像的标签"></a>镜像的标签</h2><ul>
<li>TAG<ul>
<li>ubunut:14.04</li>
<li>centos:latest</li>
</ul>
</li>
</ul>
<h2 id="查看镜像的详细信息"><a href="#查看镜像的详细信息" class="headerlink" title="查看镜像的详细信息"></a>查看镜像的详细信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line"></span><br><span class="line">docker inspect web</span><br><span class="line">docker inspect ubuntu:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>-f, –format=””</li>
</ul>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
<ul>
<li>-f, –force=false: Force removal of the image,强制删除镜像</li>
<li>–no-prune=false: Do not delete untagged parents，保留未打标签的父镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ubuntu:12.04 ubuntu:latest</span><br><span class="line">docker rmi $&#123;docker images -q ubuntu&#125; 删除Ubuntu仓库中所有镜像</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2017/07/05/docker/2017-07-05-查看和删除镜像/" data-id="cjpv19dd80008j5cp1gbicxq5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/egg/">egg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs-yaml/">nodejs yaml</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/request/">request</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lodash/">lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/koa/" style="font-size: 15px;">koa</a> <a href="/tags/lodash/" style="font-size: 20px;">lodash</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/28/egg/egg-特性/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/20/nginx/2018-09-20-Nginx错误之13Permission denied/">Nginx错误之13:Permission denied</a>
          </li>
        
          <li>
            <a href="/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/">Nginx性能优化之Keep-Alive</a>
          </li>
        
          <li>
            <a href="/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/">Nginx性能优化之Buffers</a>
          </li>
        
          <li>
            <a href="/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/">Nginx性能优化之超时</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Jax<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>