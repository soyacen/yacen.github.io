<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>蓦然回首，bug依然在灯火阑珊处</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta name="keywords" content="后端 Node.js go golang">
<meta property="og:type" content="website">
<meta property="og:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:url" content="http://yacen.github.io/page/7/index.html">
<meta property="og:site_name" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta property="og:locale" content="Zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta name="twitter:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
  
    <link rel="alternate" href="/atom.xml" title="蓦然回首，bug依然在灯火阑珊处" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蓦然回首，bug依然在灯火阑珊处</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录平时可能用到的资料</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yacen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nodejs/2015-04-24-generator-怎么样判断一个函数是Generator" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/24/nodejs/2015-04-24-generator-怎么样判断一个函数是Generator/" class="article-date">
  <time datetime="2015-04-23T16:00:00.000Z" itemprop="datePublished">2015-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/24/nodejs/2015-04-24-generator-怎么样判断一个函数是Generator/">怎么样判断一个函数是Generator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在JS中，有集中不同类型的函数：</p>
<ol>
<li>普通函数</li>
<li>generator函数</li>
<li>async函数</li>
<li>箭头函数</li>
</ol>
<p>那该怎么判断一个函数是generator函数呢？</p>
<p>阅读koa源码，发现了一个<code>is-generator-function</code>的库，学习下。</p>
<h2 id="is-generator-function"><a href="#is-generator-function" class="headerlink" title="is-generator-function"></a><code>is-generator-function</code></h2><p>这个库只暴露一个方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">isGeneratorFunction</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它首先会通过<code>typeof fn !== &#39;function&#39;</code>来检查是否是一个<code>function</code>，不是直接返回<code>false</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着会用正则表达式进一步判断。检查函数调用<code>toString()</code>方法后的字符串以<code>function*</code>做开头的。如果是的话就直接返回<code>true</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isFnRegex = <span class="regexp">/^\s*(?:function)?\*/</span>;</span><br><span class="line"><span class="keyword">var</span> fnToStr = <span class="built_in">Function</span>.prototype.toString;</span><br><span class="line"><span class="keyword">if</span> (isFnRegex.test(fnToStr.call(fn))) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后会检查当前js引擎是否有<code>Symbol</code>和<code>Symbol.toStringTag</code>等于<code>&#39;symbol&#39;</code>。因为ES6中引入了<code>Symbol</code>，参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag" target="_blank" rel="noopener">Symbol.toStringTag</a>,简单来说就是这个属性可以用来定制调用<code>Object.toString()</code>方法得到<code>[object Object]</code>中 <code>object</code> 后面的那个字符串。ES内置<code>GeneratorFunction.prototype[Symbol.toStringTag]： &#39;GeneratorFunction&#39;</code>，所以这样也能判断这个<code>fn</code>是否是<code>GeneratorFunction</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasToStringTag = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.toStringTag === <span class="string">'symbol'</span>;</span><br><span class="line"><span class="keyword">var</span> toStr = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="keyword">if</span> (!hasToStringTag) &#123;</span><br><span class="line">	<span class="keyword">var</span> str = toStr.call(fn);</span><br><span class="line">	<span class="keyword">return</span> str === <span class="string">'[object GeneratorFunction]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果这个也失效了咋办？最后一招：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getProto = <span class="built_in">Object</span>.getPrototypeOf;</span><br><span class="line"><span class="keyword">return</span> getProto(fn) === GeneratorFunction;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>fn</code>的原型。普通函数的原型是<code>[Function]</code>，而<code>generator</code>函数的原型是<code>GeneratorFunction {}</code>，所以也能判断成功。</p>
<h2 id="is-generator-function-1"><a href="#is-generator-function-1" class="headerlink" title="is-generator-function"></a><code>is-generator-function</code></h2><p>我记得<code>co</code>库里面也有判断一个函数是否是generator函数的代码，我们来看看tj大神是怎么写的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if `obj` is a generator function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Mixed&#125; obj</span></span><br><span class="line"><span class="comment"> * @return &#123;Boolean&#125;</span></span><br><span class="line"><span class="comment"> * @api private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isGeneratorFunction</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = obj.<span class="keyword">constructor</span>;</span><br><span class="line">  if (!<span class="keyword">constructor</span>) return false;</span><br><span class="line">  if ('GeneratorFunction' === <span class="keyword">constructor</span>.name || 'GeneratorFunction' === <span class="keyword">constructor</span>.displayName) return true;</span><br><span class="line">  return isGenerator(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Check if `obj` is a generator.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Mixed&#125; obj</span><br><span class="line"> * @<span class="keyword">return</span> &#123;<span class="built_in">Boolean</span>&#125;</span><br><span class="line"> * @api private</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function isGenerator(obj) &#123;</span></span><br><span class="line"><span class="regexp">  return 'function' == typeof obj.next &amp;&amp; 'function' == typeof obj.throw;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>tj大神的思路完全不一样。这个<code>fn</code>的构造函数是否是<code>GeneratorFunction</code>，接着在判断<code>fn</code>的构造函数的原型是否有<code>next</code>和<code>throw</code>方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小小的一个判断一个函数是否<code>generator</code>函数就有如此多的办法，666.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2015/04/24/nodejs/2015-04-24-generator-怎么样判断一个函数是Generator/" data-id="cjpv19dez004qj5cp79ym6xnz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nodejs/2015-03-12-nodejs的path模块源码解读" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/12/nodejs/2015-03-12-nodejs的path模块源码解读/" class="article-date">
  <time datetime="2015-03-11T16:00:00.000Z" itemprop="datePublished">2015-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/12/nodejs/2015-03-12-nodejs的path模块源码解读/">nodejs的path模块源码解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>path 模块是Node.js的核心模块之一，它主要用于路径的相关操作。</p>
<p>而路径却在Windows与UNIX上有不同的表现，所以Node.js分别做了不同的处理，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">posix.win32 = win32.win32 = win32;</span><br><span class="line">posix.posix = win32.posix = posix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>)</span><br><span class="line">  <span class="built_in">module</span>.exports = win32;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">module</span>.exports = posix;</span><br></pre></td></tr></table></figure>
<p>而两个平台的不同主要在分割符还有分上的不同，在Windows平台是<code>\\</code>,而UNIX平台上是<code>/</code>。</p>
<p>两个平台主要逻辑差不多，本文主要讲UNIX平台下的代码。</p>
<h2 id="assertPath-path"><a href="#assertPath-path" class="headerlink" title="assertPath(path)"></a><code>assertPath(path)</code></h2><p>如果当传入的path不是字符串的话就抛异常。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inspect = <span class="built_in">require</span>(<span class="string">'util'</span>).inspect;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertPath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Path must be a string. Received '</span> + inspect(path));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="normalizeStringPosix-path-allowAboveRoot"><a href="#normalizeStringPosix-path-allowAboveRoot" class="headerlink" title="normalizeStringPosix(path, allowAboveRoot)"></a><code>normalizeStringPosix(path, allowAboveRoot)</code></h2><p>此函数是处理UNIX平台上路径有 <code>.</code> 与 <code>..</code>的情况。</p>
<h2 id="format-sep-pathObject"><a href="#format-sep-pathObject" class="headerlink" title="_format(sep, pathObject)"></a><code>_format(sep, pathObject)</code></h2><p>pathObject是分装路径信息的一个对象,类似于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  root: &apos;D:\\&apos;,</span><br><span class="line">  dir: &apos;D:\\IdeaProjects\\lesson2\\log&apos;,</span><br><span class="line">  base: &apos;out.log&apos;,</span><br><span class="line">  ext: &apos;.log&apos;,</span><br><span class="line">  name: &apos;out&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此方法是为了格式化一个pathObject对象，返回格式化路径；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_format</span>(<span class="params">sep, pathObject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//给dir赋值，如果pathObject.dir，否则pathObject.root</span></span><br><span class="line">  <span class="keyword">const</span> dir = pathObject.dir || pathObject.root;</span><br><span class="line">  <span class="comment">//给base赋值，取pathObject的base或者name、ext的拼接</span></span><br><span class="line">  <span class="keyword">const</span> base = pathObject.base ||</span><br><span class="line">    ((pathObject.name || <span class="string">''</span>) + (pathObject.ext || <span class="string">''</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当pathObject.dir或者pathObject.root为空时,返回base；</span></span><br><span class="line">  <span class="keyword">if</span> (!dir) &#123;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当pathObject.root有值时候 ，返回root+base；</span></span><br><span class="line">  <span class="keyword">if</span> (dir === pathObject.root) &#123;</span><br><span class="line">    <span class="keyword">return</span> dir + base;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当pathObject.dir有值时候，返回dir+sep+base;</span></span><br><span class="line">  <span class="keyword">return</span> dir + sep + base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="format-pathObject"><a href="#format-pathObject" class="headerlink" title="format(pathObject)"></a><code>format(pathObject)</code></h2><p>次方法分Windows和UNIX系统的不同实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">pathObject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pathObject === <span class="literal">null</span> || <span class="keyword">typeof</span> pathObject !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">        <span class="string">`Parameter "pathObject" must be an object, not <span class="subst">$&#123;<span class="keyword">typeof</span> pathObject&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//UNIX是 /, windows是 \\</span></span><br><span class="line">    <span class="keyword">return</span> _format(<span class="string">'/'</span>, pathObject);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="normalize-path"><a href="#normalize-path" class="headerlink" title="normalize(path)"></a><code>normalize(path)</code></h2><p>方法会规范化给定的 path，并解析 ‘..’ 和 ‘.’ 片段。</p>
<p>当发现多个连续的路径分隔符时（如 POSIX 上的 / 与 Windows 上的 \ 或 /），它们会被单个的路径分隔符（POSIX 上是 /，Windows 上是 \）替换。 末尾的多个分隔符会被保留。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//验证path的合法性</span></span><br><span class="line">    assertPath(path);</span><br><span class="line">    <span class="comment">//如果是空字符串，返回 .</span></span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'.'</span>;</span><br><span class="line">    <span class="comment">//是否是绝对路径</span></span><br><span class="line">    <span class="keyword">const</span> isAbsolute = path.charCodeAt(<span class="number">0</span>) === <span class="number">47</span>;</span><br><span class="line">    <span class="comment">//末尾是否有分隔符</span></span><br><span class="line">    <span class="keyword">const</span> trailingSeparator = path.charCodeAt(path.length - <span class="number">1</span>) === <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准化path</span></span><br><span class="line">    path = normalizeStringPosix(path, !isAbsolute);</span><br><span class="line">    <span class="comment">//如果标准化完后的path是空字符串且不是绝对路径，path就是当前文件夹 .</span></span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">0</span> &amp;&amp; !isAbsolute)</span><br><span class="line">      path = <span class="string">'.'</span>;</span><br><span class="line">    <span class="comment">//path不是空字符串且末尾有 / ，path最后加上/</span></span><br><span class="line">    <span class="keyword">if</span> (path.length &gt; <span class="number">0</span> &amp;&amp; trailingSeparator)</span><br><span class="line">      path += <span class="string">'/'</span>;</span><br><span class="line">    <span class="comment">//如果是绝对路径，开头加 /</span></span><br><span class="line">    <span class="keyword">if</span> (isAbsolute)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'/'</span> + path;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2015/03/12/nodejs/2015-03-12-nodejs的path模块源码解读/" data-id="cjpv19df0004sj5cprmu45vw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2015-01-10-Redis数据库实现" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/10/redis/2015-01-10-Redis数据库实现/" class="article-date">
  <time datetime="2015-01-09T16:00:00.000Z" itemprop="datePublished">2015-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/10/redis/2015-01-10-Redis数据库实现/">Redis数据库实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Redis-数据库的实现方法"><a href="#Redis-数据库的实现方法" class="headerlink" title="Redis 数据库的实现方法"></a>Redis 数据库的实现方法</h2><p>在 Redis 里面,每个数据 库都是一个字典, 该字典的键和值都是我们之前提到的对象,其中:</p>
<ul>
<li>字典的键总是一个字符串 对象,它储存了用户为键设置的键名。</li>
<li>字典的值则可以是字符串 对象、列表对象、散列对象、集合对象或者有序集合 对象的其中一个。</li>
</ul>
<p>因为数据库就是字典,所以 针对数据库的操作都是基于字典操作来 实现的:</p>
<ul>
<li>比如说,使用 DEL 命令删除一个数据库键,就是删除数据库对应的字典的键值对。</li>
<li>又比如说,使用 FLUSHDB 清空数据库,就是清空数据 库对应的字典。</li>
<li>诸如此类。</li>
</ul>
<p><img src="./images/redis_o9.png" alt=""></p>
<h2 id="记录过期时间"><a href="#记录过期时间" class="headerlink" title="记录过期时间"></a>记录过期时间</h2><p>为了记录数据库键的过期时间,Redis 为每个数据库创建了另一个字典, 专门使用这个字典来记录键的<br>过期时间,其中:</p>
<ul>
<li>字典的键指向数据库键对象,也即是带有过期时间的那个键(数据库字典和储存过期时间的字典通过指针使用同一个键对象,不会造成任何 资源浪费)。</li>
<li>键的值则是一个毫秒格式的 UNIX 时间戳,记录了键到期的时间。</li>
</ul>
<p><img src="./images/redis_10.png" alt=""></p>
<h2 id="RDB-持久化实现原理"><a href="#RDB-持久化实现原理" class="headerlink" title="RDB 持久化实现原理"></a>RDB 持久化实现原理</h2><p>Redis 会遍历服务器中的所有数据 库,访问数据库中的所有键值对,并根据键值对的类型,将这些键值对以及它们的过期时间写入到 RDB 文件里面。</p>
<p><img src="./images/redis_11.png" alt=""></p>
<h2 id="AOF-持久化实现原理"><a href="#AOF-持久化实现原理" class="headerlink" title="AOF 持久化实现原理"></a>AOF 持久化实现原理</h2><p>AOF 持久化功能在每次 执行命令之后就将 协议格式的命令写入到 AOF 缓冲区,然后服 务器再定期将缓冲区的内容写入到 AOF 文件,还原数据时只要重新执行 AOF 文件里面的命令即可。</p>
<p><img src="./images/redis_12.png" alt=""></p>
<h2 id="命令处理模型"><a href="#命令处理模型" class="headerlink" title="命令处理模型"></a>命令处理模型</h2><p>Redis 服务器使用 Reactor 模式来连接多个客户端并处理命令请求,其中:</p>
<ul>
<li>客户端发送的命令请求会被放到一个有序的队列里面。</li>
<li>服务器使用单线程方式来执行命令 —— 服务器每次从队列里面取出一个 请求并处理它,只有在当前的命令请求处理完毕之后,服务器才会去处理下一个命令 请求。</li>
<li>单线程的命令处理方式使得针对服务器以及数据库的操作都不需要加 锁,好处是极大地方便了功能的实现,减少了代码出错的可能性;而坏 处则是不能最大化地使用硬件的多 线程能力。</li>
</ul>
<p><img src="./images/redis_13.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Redis 数据库中的键和值都是对象,其中键总是一个字符串 对象,而值则可以是多种类型对象的其中一个。</li>
<li>Redis 为每种对象都设置了两种或以上的表示方式,使得 对象可以在不同的 应用场景中都有最好的性能表现。</li>
<li>Redis 的数据库就是一个字典,数据 库操作都是通过字典操作来实现的;除此之外, Redis 还使用了另一个字典来专门记录键值对的过期时间。</li>
<li>RDB 持久化通过遍历数据库并将键值对写入到文件来 实现,而 AOF 持久化则通过记录服务器执行过的命令请求来实现。</li>
<li>Redis 服务器使用 Reactor 模式来处理客户端的命令请求。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2015/01/10/redis/2015-01-10-Redis数据库实现/" data-id="cjpv19dfz0077j5cpz1220elz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2015-01-05-Redis对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/05/redis/2015-01-05-Redis对象/" class="article-date">
  <time datetime="2015-01-04T16:00:00.000Z" itemprop="datePublished">2015-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/05/redis/2015-01-05-Redis对象/">Redis对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对象系统"><a href="#对象系统" class="headerlink" title="对象系统"></a>对象系统</h1><p>Redis 是一个键值对(key-value pair)数据库,数据库中的每个键都有与之对应的值,并且这些键和值<br>都是对象(object),其中:</p>
<ul>
<li>键总是一个字符串 对象(String Object)。</li>
<li>而值则可以是字符串 对象、列表对象(List Object)、散列对象(Hash Object)、集合对象(SetObject)或者有序集合 对象(Sorted Set Object / Zset Object)中的任意一个, 这五种对象分别对应我们在 Redis 数据库中操作的字符串 键值对(SET、BITOP、PFADD)、列表键值对(RPUSH、LRANGE)、散列键值对(HADD、HLEN)、集合键值对(SADD、SMEMBERS)和有序集合键值对(ZADD、ZRANGE)。</li>
</ul>
<p>举个例子,执行命令 SET msg “hello world” 会让数据库关联起一个新的键值对,其中键是一个包含内容 “msg” 的字符串对象,而值则是一个包含内容 “hello world” 的字符串对象;</p>
<p>另一方面,执行命令 SADD fruits “apple” “banana” “cherry” 则会创建一个键为字符串对象,值为集<br>合对象的键值对。<br><img src="./images/redis_o1.png" alt=""></p>
<h2 id="对象的实现"><a href="#对象的实现" class="headerlink" title="对象的实现"></a>对象的实现</h2><p>Redis 中的每种对象都有与之相 对应的底层数据结构,并且为了让对象在各种不同的 应用场景下都有优秀的性能表现,Redis 为每种对象都提供了两种 类型的数据结构实现:</p>
<ul>
<li>第一类是为了进行性能优化而特制的编码数据结构(encoded data structure),这些数据结构主要使用“以 CPU 换内存的方式”来节约内存。<ul>
<li>编码数据结构主要在对象包含的值数量比较少、或者值的体积比较小时使用:比如在字符串 对象包含的字符串比 较短时,集合只包含三五个小元素 时,又或者列表只包含十来个 项时,这些情况都可以使用编码数据结构。</li>
</ul>
</li>
<li>另一类是普通数据结构,也即是我们在书上、论文上看见的数据结构,比如双向 链表、字典、跳跃表等等。<ul>
<li>比起 编码数据结构,这些普通的数据 结构需要消耗更多内存,但是能 够提供更强大的功能,普通数据 结构主要在对象包含的值比较多、或者值的体积比较大时使用。</li>
</ul>
</li>
</ul>
<p>在创建新对象时,Redis 会优先使用编码数据结构来表示对象,并在有需要 时,自动将对象的表示方式转换为普通数据结构。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>编码数据结构:</p>
<ul>
<li>压缩列表(zip list)</li>
<li>整数集合(int set)</li>
</ul>
<p>普通数据结构:</p>
<ul>
<li>简单动态字符串(SDS, simple dynamic string)</li>
<li>双向链表</li>
<li>字典</li>
<li>跳跃表</li>
</ul>
<p>另外需要注意的是, 节约内存并不是编码数据结构所特有的 —— 普通数据结构也有相应的内存优化模式,比如 SDS 就有两种或以上的表示方式,不同的表示可以 让同一对象在不同的使用 场景下也尽可能地保持高效。</p>
<h2 id="对象与数据结构之间的关系"><a href="#对象与数据结构之间的关系" class="headerlink" title="对象与数据结构之间的关系"></a>对象与数据结构之间的关系</h2><p><img src="./images/redis_o3.png" alt=""></p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表具有以下特点:</p>
<ul>
<li>压缩列表包含的项都是有序的,列表的两端分 别为表头和表尾。</li>
<li><p>每个项可以储存一个字符串、整数或者浮点数。</p>
</li>
<li><p>可以从表头开始或者从表尾开始遍 历整个压缩列表,复杂度为 O(N) 。</p>
</li>
<li><p>定位压缩列表中指定索引上的 项,复杂度为 O(N) 。</p>
</li>
<li><p>使用压缩列表来储存值消耗的内存比使用双向 链表来储存值消耗的内存要少。<br><img src="./images/redis_o2.png" alt=""></p>
</li>
</ul>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合具有以下特点:</p>
<ul>
<li>集合元素只能是整数(最大 为 64 位),并且集合中不会出 现重复的元素。</li>
<li>集合的底层使用有序的整数数 组来表示。</li>
<li>数组的类型会随着新添加元素的 类型而改变:举个例子,如果 集合中位长度最大的元素 可以使用16 位整数来保存,那么数 组的类型就是 int16_t ,而如果集合中位 长度最大的元素可以使用 32 位整数来保存的 话,那么数组的类型就是 int32_t ,诸如此类。</li>
<li>数组的类型只会自动增大,但不会减小。</li>
</ul>
<p><img src="./images/redis_o4.png" alt=""></p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>Redis 使用 SDS (simple dynamic string)而不是 C 语言的字符串格式(以空字符 为结尾的字符数组)来作为 Redis 的默认字符串表示, SDS 具有以下特点:</p>
<ul>
<li>可以储存位数组(实现 BITOP 和 HyperLogLog)、字符串、整数和浮点数,其中超 过 64 位的整数和超过 IEEE 754 标准的浮点数使用字符串来表示。</li>
<li>具有 int 、 embstr 和 raw 三种表示形式可 选,其中 int 表示用于储存小于等于 64 位的整数,embstr 用来储存比较短的位数组和字符串,而其他格式的 值则由 raw 格式储存。</li>
<li>比起 C 语言的字符串格式, SDS 具有以下四个 优点:<ol>
<li>常数复杂度获取长度值; </li>
<li>不会引起缓冲区溢出; </li>
<li>通过预分配和惰性释放两种策略来减少内存重分配的 执行次数; </li>
<li>可以储存二进制位。</li>
</ol>
</li>
</ul>
<p><img src="./images/redis_o5.png" alt=""></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>Redis 的双向链表实现具有以下特性:</p>
<ul>
<li>双向、无环、带有表头和表尾指针。</li>
<li>一个链表包含多个项,每个项都是一个字符串 对象,换句话来说,一个列表对象可以包含多个字符串对象。</li>
<li>可以从表头或者表尾遍历整个链表,复杂度为 O(N) 。</li>
<li>定位特定索引上的 项,复杂度为 O(N) 。</li>
<li>链表带有长度记录属性,获取链表的当前长度的复杂度为 O(1) 。</li>
</ul>
<p><img src="./images/redis_o6.png" alt=""></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis 的字典实现具有以下特性:</p>
<ul>
<li>查找、添加、删除键值对的复杂度为 O(1) ,键和值都是字符串对象。</li>
<li>使用散列表(hash table)为底层实现,使用链地址法(separate chaining)来解决键冲突。</li>
<li>Redis 会在不同的地方使用不同的散列算法,其中最常用的是 MurmurHash2 算法。</li>
<li>在键值对数量大增或者大减的 时候会对散列表进行重新散列(rehash),并且这个 rehash 是渐进式、分多次进行的,不会在短 时间内耗费大量 CPU 时间,造成服务器阻塞。</li>
</ul>
<p><img src="./images/redis_o7.png" alt=""></p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>Redis 的跳跃表实现具有以下特点:</p>
<ul>
<li>支持平均 O(log N) 最坏 O(N) 复杂度的节点查找操作,并且可以通 过执行范围性(range)操作来批量地获取有序的节点。</li>
<li>跳跃表节点除了实现跳跃表所需的层(level)之外,还具有 score 属性和 obj 属性:前者是一个浮点数,用于 记录成员的分值;而后者则是一个字符串对象,用来记录成员本身。</li>
<li>和字典一起构成 ZSET 结构,用于实现 Redis 的有序集合结构:其中字典用于快速 获取元素的分值(比如实现 ZSCORE 命令),以及判断元素是否存在;而跳 跃表则用于执行范围操作(比如实现 ZRANGE 命令)。</li>
</ul>
<p><img src="./images/redis_o8.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2015/01/05/redis/2015-01-05-Redis对象/" data-id="cjpv19dg00079j5cp8valnmdb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2014-12-26-Redis集群" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/26/redis/2014-12-26-Redis集群/" class="article-date">
  <time datetime="2014-12-25T16:00:00.000Z" itemprop="datePublished">2014-12-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/26/redis/2014-12-26-Redis集群/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Redis 的分布式数据 库实现</p>
<p>Redis 集群是一个由多个 节点组成的分布式服 务器群,它具有复制、高可用和分片特性。</p>
<p>Redis 的集群没有中心 节点,并且带有复制和故障 转移特性,这可以避免单个节点成为性能瓶颈,或者因为某个节点下线而导致整个集群下 线。</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Redis 集群是一个由多个 Redis 服务器组成的分布式网 络服务器群,集群中的各个服 务器被称为节点(node),这些节点会相互连接并进行通信。</p>
<p>分布式的 Redis 集群没有中心 节点,所以用户不必担心某个 节点会成为整个集群的性能瓶 颈。</p>
<p><img src="./images/redis_c1.png" alt=""></p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Redis 集群的每个节点都有两种角色可 选,一个是主节点(master node),另一个是从 节点(slave node):其中主节点用于储存数据,而从 节点则是某个主节点的复制品。</p>
<p>当用户需要处理更多读请求的时候,添加从节点可以扩展系统的读性能。</p>
<p>因为 Redis 集群重用了单机 Redis 复制特性的代 码,所以集群的复制行 为和我们之前介绍的单机复制特性的行 为是完全一样的。<br><img src="./images/redis_c2.png" alt=""></p>
<h2 id="节点故障检测和自动故障转移"><a href="#节点故障检测和自动故障转移" class="headerlink" title="节点故障检测和自动故障转移"></a>节点故障检测和自动故障转移</h2><p>Redis 集群的主节点内置了类似 Redis Sentinel 的节点故障检测和自动故障转移功能,当集群中的某个主节点下线时,集群中的其他在 线主节点会注意到这一点,并对已下线的主节点进行故障转移。</p>
<p>集群进行故障转移的方法和 Redis Sentinel 进行故障转移的方法基本一 样,不同的是,在集群里面,故障转移是由集群中其他在 线的主节点负责进行的,所以集群不必另外使用 Redis Sentinel 。<br><img src="./images/redis_c3.png" alt=""></p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>集群使用分片来 扩展数据库的容量,并将命令 请求的负载交给不同的节点来分担。</p>
<p>集群将整个数据 库分为 16384 个槽(slot),所有键都属于这 16384 个槽的其中一个, 计算键 key属于哪个槽的公式 为 slot_number = crc16(key) % 16384 ,其中 crc16 为 16 位的循环冗余校验和函数。</p>
<p>集群中的每个主 节点都可以处理 0 个至 16384 个槽,当 16384 个槽都有某个 节点在负责处理时,集群进入上线状态,并开始处理客户端发送的数据命令 请求。</p>
<p>比如说,如果我们有三个主节点 7000 、 7001 和 7002 ,那么我们可以:</p>
<ul>
<li>将槽 0 至 5460 指派给节点 7000 负责处理;</li>
<li>将槽 5461 至 10922 指派给节点 7001 负责处理;</li>
<li>将槽 10923 至 16383 指派给节点 7002 负责处理;</li>
</ul>
<p>这样就可以将 16384 个槽平均地指派 给三个节点负责处理。</p>
<h2 id="转向"><a href="#转向" class="headerlink" title="转向"></a>转向</h2><p>对于一个被指派了槽的主 节点来说,这个主节点只会处理属于指派给自己的槽的命令 请求。</p>
<p>如果一个节点接收到了和自己 处理的槽无关的命令 请求,那么节点会向客户端返回一个转向错误(redirection error),告诉客户端,哪个节点才是负责处理这条命令的,之后客 户端需要根据错误中包含的地址和端口号重新向正确的 节点发送命令请求。<br><img src="./images/redis_c4.png" alt=""></p>
<h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><h2 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h2><p>搭建一个 Redis 集群需要执行以下步骤:</p>
<ol>
<li>创建多个节点。</li>
<li>为每个节点指派槽,并将多个 节点连接起来,组成一个集群。</li>
<li>当集群数据库的 16384 个槽都有节点在处理时,集群进入上线状态。</li>
</ol>
<p>接下来,就让我们来搭建一个包含六个 节点的 Redis 集群,其中三个 节点为主节点,而另外三个 节点为从节点,每个主节点都有一个从 节点。</p>
<p>注意,在极端情况下,如果将 16384 个槽都指派给一个主节点,那么只有一个主 节点也可以让集群进入上线状态,但是要让集群的故障转移特性生效,最起 码要有三个主节点;而要让故障转移真正有意义,最少要为三个主节点分别设置一个从节点,这也是我们使用六个节点作为例子的原因。</p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>集群中的节点就是运行在集群模式下的 Redis 服务器,为了构建一个集群,我 们需要一一创建集群中的每个节点。</p>
<p>为了让 Redis 服务器以集群模式运行,我 们需要在启动服务器时,打开服务器的集群模式 选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure></p>
<p>另外,如果有多个 节点运行在同一台机器里面,那么我 们还需要为每个节点指定不同的端口号:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br></pre></td></tr></table></figure></p>
<p>我们可以将这两个配置值写入到 redis.conf 文件里面,然后 执行以下命令来启 动一个节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server redis.conf</span><br></pre></td></tr></table></figure></p>
<h2 id="节点创建示例"><a href="#节点创建示例" class="headerlink" title="节点创建示例"></a>节点创建示例</h2><p>为了在同一台机器上构建一个包含六个 节点的集群,其中三个主 节点分别运行在机器的 7000 、7001 和 7002 端口,而三个从 节点则分别运行在机器的 7003 、 7004 和 7005 端口,我们可以先创建一个 rediscluster 文件夹,然后分别创建 7000 至 7005 这六个文件夹,每个文件夹都包含一个redis.conf 文件,它的内容 为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port &lt;number&gt;</span><br><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure></p>
<p>然后只要分别执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/rediscluster/7000$ redis-server redis.conf</span><br><span class="line">...</span><br><span class="line">~/rediscluster/7005$ redis-server redis.conf</span><br></pre></td></tr></table></figure></p>
<p>就可以创建出六个节点了(节点启动时默认为主节点,之后要将其中三个 节点转为从节点)。</p>
<h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>在创建出六个节点之后,我们需要让这六个节点互相连接以构成一个集群,然后 为三个主节点指派槽,并为这三个主节点分别设置一个从节点。</p>
<p>创建集群的操作可以通过使用位于 Redis 安装文件夹内的 redis-trib.rb 程序来完成,这是一个使用 Ruby 编写的 Redis 集群管理程序,它具有创建集群、检查集群的上线情况和槽指派情况、对集群进行重新分片、向集群添加新节点或者从集群中移除节点等功能。</p>
<p>为了创建一个包含三个主 节点和三个从节点的集群,我 们需要执行以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure></p>
<ul>
<li>create 表示我们要创建一个集群</li>
<li>–replicas 1 则表示让 redis-trib.rb 为集群中的每个主节点设置一个从节点</li>
<li>再之后输入的是各个节点的 IP 地址和端口号。</li>
</ul>
<h2 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h2><p>集群客户端<br>因为集群功能比起 单机功能要复杂得多,所以不同 语言的 Redis 客户端通常需要为集群添加特别的支持,或者专门开发一个集群客户端。</p>
<p>目前主要的 Redis 集群客户端(或者说,支持集群功能的 Redis 客户端)有以下这些:</p>
<ul>
<li>redis-rb-cluster:antirez 使用 Ruby 编写的 Redis 集群客户端,集群客户端的官方实现。</li>
<li>predis:Redis 的 PHP 客户端,支持集群功能。</li>
<li>jedis:Redis 的 JAVA 客户端,支持集群功能。</li>
<li>StackExchange.Redis:Redis 的 C# 客户端,支持集群功能。</li>
<li>内置的 redis-cli :在启动时给定 -c 参数即可进入集群模式,支持部分集群功能。</li>
</ul>
<h2 id="连接节点并执行命令"><a href="#连接节点并执行命令" class="headerlink" title="连接节点并执行命令"></a>连接节点并执行命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 -c</span><br><span class="line">127.0.0.1:7000&gt; SET date 2014-10-10    # 键 date 所在的槽位于 节点 7000 ,节点直接执行命令</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; SET msg &quot;hello world&quot; # 键 msg 所在的槽位于 节点 7001</span><br><span class="line">-&gt; Redirected to slot [6257] located at 127.0.0.1:7001 # 客户端从 7000 转向至 7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; SADD fruits “apple” “banana” “cherry” # 键 fruits 所在的槽位于 节点 7002</span><br><span class="line">-&gt; Redirected to slot [14943] located at 127.0.0.1:7002 # 客户端从 7001 转向至 7002</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:7002&gt; # 转向是自动完成的,无需任何用 户操作</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2014/12/26/redis/2014-12-26-Redis集群/" data-id="cjpv19dfy0075j5cpp15m9895" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2014-12-23-Redis哨兵" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/23/redis/2014-12-23-Redis哨兵/" class="article-date">
  <time datetime="2014-12-22T16:00:00.000Z" itemprop="datePublished">2014-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/23/redis/2014-12-23-Redis哨兵/">Redis哨兵</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>监视主从服务器,并在主服 务器下线时自动进行故障转移</p>
<h2 id="启动-Redis-Sentinel"><a href="#启动-Redis-Sentinel" class="headerlink" title="启动 Redis Sentinel"></a>启动 Redis Sentinel</h2><p>通过执行 Redis 安装文件夹中的 redis-sentinel 程序,可以启 动一个 Sentinel 实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure></p>
<p>因为 Redis 的 Sentinel 实际上就是一个运行在 Sentienl 模式下的 Redis 服务器,所以我们同样可以使用以下命令来启 动一个 Sentinel 实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p>
<p>启动 Sentinel 时需要指定配置文件,该文件记录了要监视的主服务器,以及相关的配置参数</p>
<h2 id="使用-Sentienl-监视主服务器以及它的从服务器"><a href="#使用-Sentienl-监视主服务器以及它的从服务器" class="headerlink" title="使用 Sentienl 监视主服务器以及它的从服务器"></a>使用 Sentienl 监视主服务器以及它的从服务器</h2><p>每个 Sentinel 实例可以监视任意多个主服 务器,以及被监视的主服务器属下的所有从服 务器。<br><img src="./images/redis_sq.png" alt=""></p>
<h2 id="Sentinel-网络"><a href="#Sentinel-网络" class="headerlink" title="Sentinel 网络"></a>Sentinel 网络</h2><p>多个 Sentinel 实例可以监视同一个主服务器,监视相同主服务器的这些 Sentinel 们会自动地互相连接,组成一个分布式的 Sentinel 网络,互相通信并交换彼此关于被监视服务器的信息。</p>
<p><img src="./images/sw.png" alt=""></p>
<h2 id="服务器下线判断"><a href="#服务器下线判断" class="headerlink" title="服务器下线判断"></a>服务器下线判断</h2><p>当一个 Sentinel 认为被监视的服务器已经下线时,它会向网络中的其他 Sentinel 进行确认,判断该服务器是否真的已 经下线。</p>
<p>如果下线的服务器为主服务器,那么 Sentinel 网络将对下线主服务器进行自动故障转移:通过将下线主服务器的某个从服 务器提升为新的服务器,并让其他从服务器转为复制新的主服 务器,以此来让系统重新回到上线状态。</p>
<h2 id="Sentinel-的配置"><a href="#Sentinel-的配置" class="headerlink" title="Sentinel 的配置"></a>Sentinel 的配置</h2><p>监视配置选项</p>
<p>Sentinel 在启动时必须指定相应的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure></p>
<p>一个 Sentinel 配置文件至少要包含一个 监视配置选项,用于指定被 监视主服务器的相关信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>name 是用户为被监视主服务器设置的名字,</li>
<li>ip 和 port 则是被监视主服务器的 IP 地址和端口号,</li>
<li>quorum 为确认这个主服务器已下线所需要的最少 Sentinel 数量。</li>
</ul>
<p>举个例子,配置 <code>sentinel monitor mymaster 127.0.0.1 6379 2</code>表示要监视的主服务器的名字为mymaster ,它的 IP 地址为 127.0.0.1 ,端口号为 6379 ,而确认这个主服务器已下线最少需要两个Sentinel 同意。</p>
<p>Sentinel 可以自动发现并监视主服务器属下的所有从服 务器,所以用户只需要给出主服务器的地址和端口号就可以了。</p>
<p>端口配置选项</p>
<p>如果要在同一台机器上运行多个 Sentinel 实例,用户还需要通过 port <number> 选项来为每个Sentinel 设置不同的端口号,如果不 进行设置,那么 Sentinel 的默认端口号为 26379 。</number></p>
<p>举个例子,如果要在同一台机器上运行两个 Sentinel 实例,用户可以通过载入以下两个配置文件来分别将两个 Sentinel 实例的端口号设置为 26379 和 26380 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sentinel1.conf</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sentinel2.conf</span><br><span class="line">port 26380</span><br><span class="line">sentinel monitor ...</span><br></pre></td></tr></table></figure>
<p>执行以下两条命令,将 创建两个监视主服务器 s1的 Sentinel 实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel sentinel1.conf</span><br><span class="line">$ redis-sentinel sentinel2.conf</span><br></pre></td></tr></table></figure></p>
<p>其中 sentinel1.conf 的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">sentinel monitor s1 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure></p>
<p>而 sentinel2.conf 的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 26380</span><br><span class="line">sentinel monitor s1 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2014/12/23/redis/2014-12-23-Redis哨兵/" data-id="cjpv19dfx0073j5cpryp1oy3v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2014-12-22-Redis复制集" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/22/redis/2014-12-22-Redis复制集/" class="article-date">
  <time datetime="2014-12-21T16:00:00.000Z" itemprop="datePublished">2014-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/22/redis/2014-12-22-Redis复制集/">Redis复制集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>Redis 的复制(replication)功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品,其中被复制的服 务器为主服务(master),而通过复制创建出来的服务器复制品则为从服务器(slave)。</p>
<p>主从服务器两者拥有相同的数据 库数据:</p>
<p>只要主从服务器之间的网络连接正常,主服 务器就会一直将发生在自己身上的数据更新同步 给从服务器,从而一直保 证主从服务器的数据相同。</p>
<p><img src="./images/redis_replica.png" alt=""></p>
<h2 id="使用从服务器来处理读命令请求"><a href="#使用从服务器来处理读命令请求" class="headerlink" title="使用从服务器来处理读命令请求"></a>使用从服务器来处理读命令请求</h2><p>Redis 允许从服务器执行客户端发送的读命令,比如 GET 、LRANGE、SMEMBERS、HGET、ZRANGE 等等。</p>
<p>因为主从服务器拥有相同的数据 库数据,所以从服务器在执行客户端发送的读命令时,获得的结果与<br>主服务器执行相同的读命令所获得的结果是一样的。</p>
<p>因此,用户可以将原本由主服 务器负责处理的一部分(甚至全部) 读命令请求转交给从服务器处理,从而降低主服 务器在处理读命令请求方面的负载,并扩展整个系统处理读命令请求的能力。<br><img src="./images/redis_s.png" alt=""></p>
<h2 id="通过复制来扩展系统处理读请求的能力"><a href="#通过复制来扩展系统处理读请求的能力" class="headerlink" title="通过复制来扩展系统处理读请求的能力"></a>通过复制来扩展系统处理读请求的能力</h2><p>通过添加从服务器可以<em>线性</em>地扩展整个系统处理读命令请求的能力。<br><img src="./images/redis_se.png" alt=""></p>
<h2 id="创建从服务器的方法"><a href="#创建从服务器的方法" class="headerlink" title="创建从服务器的方法"></a>创建从服务器的方法</h2><p>Redis 提供了两种方法来 为某个主服务器创建从服务器:</p>
<ol>
<li>使用 <code>SLAVEOF &lt;master-ip&gt; &lt;master-port&gt;</code> 命令<ul>
<li>比如向一个服 务器发送 <code>SLAVEOF 127.0.0.1 6379</code> ,可以让接收到该命令的服务器变为 127.0.0.1:6379 的从服务器。</li>
<li>在将一个服务器设置成从服务器之后,可以通 过向它发送 SLAVEOF no one 来让它变回一个主服务器(数据库已有的数据会被保留)。</li>
</ul>
</li>
<li>在启动服务器时,通过设置 <code>slaveof &lt;master-ip&gt; &lt;master-port&gt;</code> 配置选项来让服务器成为指定服务器的从服务器。</li>
</ol>
<h2 id="服务器在复制时遭遇下线"><a href="#服务器在复制时遭遇下线" class="headerlink" title="服务器在复制时遭遇下线"></a>服务器在复制时遭遇下线</h2><p>在实际的世界中,因 为故障而导致服务器下线的情况总是不可避免的。</p>
<p>在一个由主服 务器和从服务器组成的系统中,主服务器或者从服务器都有可能会下 线,但是不同服 务<br>器下线带来的影响并不相同:</p>
<ul>
<li>如果下线的是从服务器,那么整个系 统处理读请求的性能将有所下降,但 整个系统仍然可以继续处理写请求和读请求,所以这种下线不会导致系统停机;</li>
<li>另一方面,因 为在整个系统里面,只有主服 务器一个能够处理写请求,所以如果下 线的是主服务器,那么整个系 统将只能处理读请求而无法处理写请求,导致系统停机。</li>
</ul>
<h2 id="从服务器下线示例"><a href="#从服务器下线示例" class="headerlink" title="从服务器下线示例"></a>从服务器下线示例</h2><p>从服务器 B 下线,导致客户端 C 的访问失败,但只要客户端 C 改为访问其他在线的服务器,就可以解决 这个问题。<br><img src="./images/redis_sd.png" alt=""></p>
<h2 id="主服务器下线示例"><a href="#主服务器下线示例" class="headerlink" title="主服务器下线示例"></a>主服务器下线示例</h2><p>主服务器下线导致主从服务器的连接中断,并使得整个系 统无法再执行写命令。</p>
<p>这时从服务器还是可以继续处理读请求的,但是从服 务器的数据会因为主服务器下线而没办法再得到更新。<br><img src="./images/redis_md.png" alt=""></p>
<h2 id="让系统重新上线的方法"><a href="#让系统重新上线的方法" class="headerlink" title="让系统重新上线的方法"></a>让系统重新上线的方法</h2><p>为了让系统能够回到正常上线状态(也即是,让系统中的服务器既能够处理读请求,又能够处理写请求),用户需要向系统中的某一个从服 务器发送 <code>SLAVEOF no one</code> 命令,让它变为新的主服务器,并向其他从服务器发送 <code>SLAVEOF newip port</code>命令,让它们去复制新的从服 务器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2014/12/22/redis/2014-12-22-Redis复制集/" data-id="cjpv19dfx0071j5cpjycf7wgm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2014-12-20-Redis管理工具" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/20/redis/2014-12-20-Redis管理工具/" class="article-date">
  <time datetime="2014-12-19T16:00:00.000Z" itemprop="datePublished">2014-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/20/redis/2014-12-20-Redis管理工具/">Redis管理工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RedisLive"><a href="#RedisLive" class="headerlink" title="RedisLive"></a>RedisLive</h1><p><a href="https://github.com/nkrode/RedisLive" target="_blank" rel="noopener">https://github.com/nkrode/RedisLive</a></p>
<h1 id="redis-commander"><a href="#redis-commander" class="headerlink" title="redis-commander"></a>redis-commander</h1><p><a href="https://github.com/joeferner/redis-commander" target="_blank" rel="noopener">https://github.com/joeferner/redis-commander</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2014/12/20/redis/2014-12-20-Redis管理工具/" data-id="cjpv19dfw006zj5cpddt4vbwi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2014-12-17-RedisLua脚本" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/17/redis/2014-12-17-RedisLua脚本/" class="article-date">
  <time datetime="2014-12-16T16:00:00.000Z" itemprop="datePublished">2014-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/17/redis/2014-12-17-RedisLua脚本/">RedisLua脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><ol>
<li><p>使用脚本可以直接在服 务器端执行 Redis 命令,一般的数据 处理操作可以直接使用 Lua 语言或者 Lua 解释器提供的函数 库来完成,不必再返回 给客户端进行处理。</p>
</li>
<li><p>所有脚本都是以事 务的形式来执行的,脚本在 执行过程中不会被其他工作打断,也不会引起任何 竞争条件,完全可以使用 Lua 脚本来代替事 务和乐观锁。</p>
</li>
<li><p>所有脚本都是可重用的,也即是 说,重复执行相同的操作 时,只要调用储存在服务器内部的脚本 缓存就可以了,不用重新 发送整个脚本,从而尽可能地 节约网络资源。</p>
</li>
</ol>
<h2 id="执行-Lua-脚本"><a href="#执行-Lua-脚本" class="headerlink" title="执行 Lua 脚本"></a>执行 Lua 脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>script 参数是要执行的 Lua 脚本。</li>
<li>numkeys 是脚本要处理的数据库键的数量,之后的 key [key …] 参数指定了脚本要 处理的数据库键,被传入的键可以在脚本里面通 过访问 KEYS 数组来取得,比如 KEYS[1] 就取出第一个 输入的键,KEYS[2] 取出第二个输入的键,诸如此类。</li>
<li>arg [arg …] 参数指定了脚本要用到的参数,在脚本里面可以通 过访问 ARGV 数组来获取这些参数。显式地指定脚本里面用到的 键是为了配合 Redis 集群对键的检查,如果不这样做的话,在集群里面使用脚本可能会出 错。</li>
</ul>
<p>另外,通过显式地指定脚本要用到的数据 库键以及相关参数,而不是将数据 库键和参数硬写在脚本里面,用户可以更方便地重用同一个脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return redis.call(&apos;PING&apos;)&quot; 0   # 在 Lua 脚本里面执行 PING 命令</span><br><span class="line">PONG</span><br><span class="line">redis&gt; EVAL &quot;return redis.call(&apos;DBSIZE&apos;)&quot; 0  # 在 Lua 脚本里面执行 DBSIZE 命令</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"># 在 Lua 脚本里面执行 GET 命令,取出键 msg 的值,并对值进行字符串拼接操作</span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; EVAL &quot;return &apos;The message is: &apos; .. redis.call(&apos;GET&apos;, KEYS[1]) &apos;&quot; 1 msg</span><br><span class="line">&quot;The message is: hello world&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="redis-call-和-redis-pcall-的区别"><a href="#redis-call-和-redis-pcall-的区别" class="headerlink" title="redis.call() 和 redis.pcall() 的区别"></a>redis.call() 和 redis.pcall() 的区别</h2><p>redis.call() 和 redis.pcall() 都可以用来执行 Redis 命令,它们的不同之处在于，当被执行的脚本出错时：</p>
<ul>
<li>redis.call() 会返回出错脚本的名字以及 EVAL 命令的错误信息</li>
<li>redis.pcall() 只返回 EVAL 命令的错误信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return redis.call(&apos;NotExistsCommand&apos;)&quot; 0</span><br><span class="line">(error) ERR Error running script (call to f_ddabd662fa0a8e105765181ee7606562c1e6f1ce):</span><br><span class="line">@user_script:1: @user_script: 1: Unknown Redis command called from Lua script</span><br><span class="line"></span><br><span class="line">redis&gt; EVAL &quot;return redis.pcall(&apos;NotExistsCommand&apos;)&quot; 0</span><br><span class="line">(error) @user_script: 1: Unknown Redis command called from Lua script</span><br></pre></td></tr></table></figure>
<p>换句话来说,在被执行的脚本出错时, redis.call() 可以提供更详细的错误信息,方便进行查错。</p>
<h2 id="使用-EVALSHA-来减少网络资源损耗"><a href="#使用-EVALSHA-来减少网络资源损耗" class="headerlink" title="使用 EVALSHA 来减少网络资源损耗"></a>使用 EVALSHA 来减少网络资源损耗</h2><p>任何 Lua 脚本,只要被 EVAL 命令执行过一次,就会被 储存到服务器的脚本缓存里面,用户只要通过 EVALSHA 命令,指定被 缓存脚本的 SHA1 值,就可以在不 发送脚本的情况下,再次 执行脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure></p>
<p>通过 SHA1 值来重用返回 ‘hello world’ 信息的脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return &apos;hello world&apos;&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">redis&gt; EVALSHA 5332031c6b470dc5a0dd9b4bf2030dea6d65de91 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure></p>
<p>通过 SHA1 值来重用之前实现的 ZDECRBY 命令,这样就不用每次都 发送整个脚本了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVALSHA 918130cae39ff0759b8256948742f77300a91cb2 1 salary 500 peter</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<h2 id="脚本管理命令"><a href="#脚本管理命令" class="headerlink" title="脚本管理命令"></a>脚本管理命令</h2><p>检查 sha1 值所代表的脚本是否已经被加入到脚本缓存里面,是的话返回 1 ,不是的话返回 0 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT EXISTS sha1 [sha1 ...]</span><br></pre></td></tr></table></figure></p>
<p>将脚本储存到脚本缓存里面,等待将来 EVALSHA 使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD script</span><br></pre></td></tr></table></figure></p>
<p>清除脚本缓存储存的所有脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT FLUSH</span><br></pre></td></tr></table></figure></p>
<p>杀死运行超时的脚本。如果脚本已经执行过写入操作,那么还需要使用 SHUTDOWN NOSAVE 命令来强制服务器不保存数据,以免错误的数据被保存到数据库里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT KILL</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2014/12/17/redis/2014-12-17-RedisLua脚本/" data-id="cjpv19dfw006xj5cp4oppe73k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis/2014-12-14-Redis运行时更改master-slave" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/14/redis/2014-12-14-Redis运行时更改master-slave/" class="article-date">
  <time datetime="2014-12-13T16:00:00.000Z" itemprop="datePublished">2014-12-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/14/redis/2014-12-14-Redis运行时更改master-slave/">Redis运行时更改master-slave</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="运行时更改master-slave"><a href="#运行时更改master-slave" class="headerlink" title="运行时更改master-slave"></a>运行时更改master-slave</h2><ol>
<li><p>修改一台slave(设为A)为new master </p>
<ol>
<li>命令该服务不做其他redis服务的slave <ul>
<li>命令: <code>slaveof no one</code> </li>
</ul>
</li>
<li>修改其readonly为yes</li>
</ol>
</li>
<li><p>其他的slave再指向new master A</p>
<ol>
<li>命令该服务为new master A的slave<ul>
<li>命令格式 <code>slaveof IP port</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="监控工具-sentinel"><a href="#监控工具-sentinel" class="headerlink" title="监控工具 sentinel"></a>监控工具 sentinel</h2><ul>
<li>Sentinel不断与master通信,获取master的slave信息.</li>
<li>监听master与slave的状态</li>
<li>如果某slave失效,直接通知master去除该slave.</li>
<li>如果master失效,,是按照slave优先级(可配置), 选取1个slave做 new master,把其他slave–&gt; new master</li>
</ul>
<h2 id="疑问-sentinel与master通信-如果某次因为master-IO操作频繁-导致超时"><a href="#疑问-sentinel与master通信-如果某次因为master-IO操作频繁-导致超时" class="headerlink" title="疑问: sentinel与master通信,如果某次因为master IO操作频繁,导致超时,"></a>疑问: sentinel与master通信,如果某次因为master IO操作频繁,导致超时,</h2><ul>
<li>此时,认为master失效,很武断.</li>
<li>解决: sentnel允许多个实例看守1个master, 当N台(N可设置)sentinel都认为master失效,才正式失效.</li>
</ul>
<h2 id="Sentinel选项配置"><a href="#Sentinel选项配置" class="headerlink" title="Sentinel选项配置"></a>Sentinel选项配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 26379 # 端口</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 # 给主机起的名字(不重即可), 当2个sentinel实例都认为master失效时,正式失效</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000  # 多少毫秒后连接不到master认为断开</span><br><span class="line">sentinel can-failover mymaster yes #是否允许sentinel修改slave-&gt;master. 如为no,则只能监控,无权修改./</span><br><span class="line">sentinel parallel-syncs mymaster 1 # 一次性修改几个slave指向新的new master.</span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 在重新配置new master,new slave过程,可以触发的脚本</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2014/12/14/redis/2014-12-14-Redis运行时更改master-slave/" data-id="cjpv19dfu006tj5cpudxqs2op" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/egg/">egg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs-yaml/">nodejs yaml</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/request/">request</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lodash/">lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/koa/" style="font-size: 15px;">koa</a> <a href="/tags/lodash/" style="font-size: 20px;">lodash</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/28/egg/egg-特性/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/20/nginx/2018-09-20-Nginx错误之13Permission denied/">Nginx错误之13:Permission denied</a>
          </li>
        
          <li>
            <a href="/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/">Nginx性能优化之Keep-Alive</a>
          </li>
        
          <li>
            <a href="/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/">Nginx性能优化之Buffers</a>
          </li>
        
          <li>
            <a href="/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/">Nginx性能优化之超时</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Jax<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>