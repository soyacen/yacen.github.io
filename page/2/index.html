<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>蓦然回首，bug依然在灯火阑珊处</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta name="keywords" content="后端 Node.js go golang">
<meta property="og:type" content="website">
<meta property="og:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:url" content="http://yacen.github.io/page/2/index.html">
<meta property="og:site_name" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta property="og:locale" content="Zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta name="twitter:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
  
    <link rel="alternate" href="/atom.xml" title="蓦然回首，bug依然在灯火阑珊处" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蓦然回首，bug依然在灯火阑珊处</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录平时可能用到的资料</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yacen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nginx/2018-08-14-Nginx优化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/14/nginx/2018-08-14-Nginx优化/" class="article-date">
  <time datetime="2018-08-13T16:00:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/nginx/2018-08-14-Nginx优化/">Nginx优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="性能的服务器的架设"><a href="#性能的服务器的架设" class="headerlink" title="性能的服务器的架设"></a>性能的服务器的架设</h2><p>对于高性能网站 ,请求量大,如何支撑?</p>
<ol>
<li>要减少请求,对于开发人员要合并css、图片, 减少mysql查询等.</li>
<li>对于运维 nginx的expires ,利用浏览器缓存等,减少查询.</li>
<li>利用cdn来响应请求</li>
<li>最终剩下的,不可避免的请求—-服务器集群+负载均衡来支撑.</li>
</ol>
<p>所以,来到第4步后,就不要再考虑减少请求这个方向了.<br>而是思考如何更好的响应高并发请求.</p>
<ul>
<li>既然响应是不可避免的,我们要做的是把工作内容”平均”分给每台服务器.</li>
<li>最理想的状态 每台服务器的性能都被充分利用.</li>
</ul>
<h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p>4台服务器,组成集群,目标每天1000W PV</p>
<p>并发数与PV的转换公式:</p>
<p>每天请求量     : pv       , 10000000<br>每PV带来的总请求: rel,   2<br>每请求悲观时长: reqtime ,记为2<br>前端服务器数量: snum   , 1台<br>每天的秒数     sec:   86400<br>峰值倍增系数   fact: 3<br>并发数:          conn</p>
<p>pv <em> fact </em> rel <em> reqtime = sec </em> snum * conn<br>conn = 1388.<br>目标: 并发1500,且响应时间在2秒内</p>
<h2 id="日志观察"><a href="#日志观察" class="headerlink" title="日志观察"></a>日志观察</h2><p>主要武器</p>
<ol>
<li>利用dmesg查看系统调试信息</li>
<li>利用nginx error log查看错误信息</li>
<li>增加nginx统计模块<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx/ \</span><br><span class="line">--add-module=/app/ngx_http_consistent_hash-master \</span><br><span class="line">--with-http_stub_status_module</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /nginx_status &#123;</span><br><span class="line">        # Turn on stats</span><br><span class="line">        stub_status on;</span><br><span class="line">        access_log   off;</span><br><span class="line">        # only allow access from 192.168.1.5 #</span><br><span class="line">        allow 192.168.1.5;</span><br><span class="line">        deny all;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断nginx的瓶颈"><a href="#判断nginx的瓶颈" class="headerlink" title="判断nginx的瓶颈"></a>判断nginx的瓶颈</h2><ol>
<li><p>首先把ab测试端的性能提高,使之能高并发的请求.</p>
<ul>
<li>易出问题: too many open files</li>
<li>原因 :  ab在压力测试时,打开的socket过多</li>
<li>解决: ulimit -n 30000 (重启失效)</li>
<li>观察结果: nginx 不需要特殊优化的情况下, 5000个连接,1秒内响应. </li>
<li>满足要求,但 wating状态的连接过多.</li>
</ul>
</li>
<li><p>解决waiting进程过多的问题.</p>
<ul>
<li>解决办法: keepalive_timeout = 0;  </li>
<li>即: 请求结果后,不保留tcp连接. </li>
<li>在高并发的情况下, keepalive会占据大量的socket连接.</li>
<li>结果: waiting状态的连接明显减少.</li>
</ul>
</li>
<li><p>解决服务端 too many open files</p>
<ul>
<li>分析: nginx要响应, <ol>
<li>是要建立socket连接,</li>
<li>是要读本地文件</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="系统内核层面"><a href="#系统内核层面" class="headerlink" title="系统内核层面:"></a>系统内核层面:</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo 4096 &gt; /proc/sys/net/core/somaxconn    # 允许等待中的监听</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle    # tcp连接快速回收</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse     # tcp连接重用   </span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies   # 不抵御洪水攻击</span><br><span class="line">echo 6000   &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets # 系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息</span><br><span class="line"></span><br><span class="line">ulimit -n 50000  最大文件描述符</span><br></pre></td></tr></table></figure>
<h3 id="防火墙-建议关掉"><a href="#防火墙-建议关掉" class="headerlink" title="防火墙(建议关掉)"></a>防火墙(建议关掉)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.nf_conntrack_max = 655350  </span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 120</span><br></pre></td></tr></table></figure>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max = 655360   系统最大文件描述符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程最大文件描述符 /etc/security/limits.conf</span><br><span class="line">soft nofile 50000</span><br><span class="line">hard nofile 50000</span><br></pre></td></tr></table></figure>
<h2 id="Nginx层面"><a href="#Nginx层面" class="headerlink" title="Nginx层面:"></a>Nginx层面:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">work_processers  CPU*[1,2]; 打开的进程数量,为CPU核心数即可</span><br><span class="line">worker_connections 65535; # 每进程最大连接数</span><br><span class="line">worker_rlimit_nofile 30000; 进程打开文件的最大数量</span><br><span class="line">keepalive_timeout  0;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/14/nginx/2018-08-14-Nginx优化/" data-id="cjpduyilt003ekqcpz5kfxz8x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-08-06-Nginx负载均衡" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/nginx/2018-08-06-Nginx负载均衡/" class="article-date">
  <time datetime="2018-08-05T16:00:00.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/nginx/2018-08-06-Nginx负载均衡/">Nginx负载均衡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡介绍见<a href="https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">百度百科</a></p>
<h2 id="Nginx实现负载均衡"><a href="#Nginx实现负载均衡" class="headerlink" title="Nginx实现负载均衡"></a>Nginx实现负载均衡</h2><p>具体见<a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="noopener">load_balancing</a><br>和<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">ngx_http_upstream_module</a></p>
<h2 id="负载均衡方法"><a href="#负载均衡方法" class="headerlink" title="负载均衡方法"></a>负载均衡方法</h2><p>nginx支持以下负载均衡机制：</p>
<ul>
<li>循环 - 对应用程序服务器的请求以循环方式分发，</li>
<li>最少连接 - 下一个请求被分配给活动连接数最少的服务器，</li>
<li>ip-hash - 哈希函数用于确定应为下一个请求选择哪个服务器（基于客户端的IP地址）。</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>未特别配置负载平衡方法，则默认为循环。</p>
<p>如下，三个服务器轮询的接受请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream myapp1 &#123;</span><br><span class="line">        server srv1.example.com;</span><br><span class="line">        server srv2.example.com;</span><br><span class="line">        server srv3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h2><p>使用 least_conn 指令 开启最少连接。</p>
<p>使用最少连接的负载平衡，nginx将尽量不会使繁忙的应用程序服务器过载请求，而是将新请求分发给不太繁忙的服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream myapp1 &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server srv1.example.com;</span><br><span class="line">    server srv2.example.com;</span><br><span class="line">    server srv3.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ip-hash-会话保持"><a href="#ip-hash-会话保持" class="headerlink" title="ip_hash(会话保持)"></a>ip_hash(会话保持)</h2><p>通过循环或最少连接的负载平衡，每个后续客户端的请求可能会分发到不同的服务器。无法保证同一客户端始终指向同一服务器。</p>
<p>使用ip-hash，客户端的IP地址将用作散列密钥，以确定应为客户端的请求选择服务器组中的哪个服务器。此方法可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream myapp1 &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server srv1.example.com;</span><br><span class="line">    server srv2.example.com;</span><br><span class="line">    server srv3.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加权"><a href="#加权" class="headerlink" title="加权"></a>加权</h2><p>通过使用权重，可以进一步影响nginx负载平衡算法。</p>
<p>在上面的示例中，未配置服务器权重，这意味着所有指定的服务器都被视为对特定负载平衡方法具有同等资格。</p>
<p>特别是对于循环，默认是平等分配请求。加权后，权重越大，分配的请求越多。</p>
<p>同样可以在 最少连接 和 ip-hash 中使用权重。</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>每5个新请求将分布在应用程序实例中，如下所示：3个请求将定向到srv1，一个请求将转到srv2，另一个请求转到srv3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myapp1 &#123; </span><br><span class="line">    server srv1.example.com weight = 3; </span><br><span class="line">    server srv2.example.com; </span><br><span class="line">    server srv3.example.com; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>nginx中的反向代理实现包括带内（或被动）服务器运行状况检查。如果来自特定服务器的响应失败并显示错误，则nginx会将此服务器标记为失败，并将尝试避免为后续入站请求选择此服务器一段时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myapp1 &#123; </span><br><span class="line">    server srv1.example.com weight = 3; </span><br><span class="line">    server srv2.example.com max_fails=3 fail_timeout=30s;</span><br><span class="line">    server srv3.example.com; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当srv2在 fail_timeout 30秒 没有响应，则标记1次失败，当超过max_fails 3 次时，后续请求将忽略serv2。</p>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>使用轮询来做个栗子。</p>
<ol>
<li><p>配置nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">upstream nodeserver &#123;</span><br><span class="line">    ip_hash;#加上这个，解决Session每次访问页面都不一样，加上就一样了。</span><br><span class="line">    server localhost:8000;</span><br><span class="line">    server localhost:8001 max_fails=3 fail_timeout=5s;</span><br><span class="line">    server localhost:8002;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 192.168.1.36;</span><br><span class="line"></span><br><span class="line">    location / &#123; </span><br><span class="line">        proxy_pass       http://nodeserver;</span><br><span class="line">        proxy_set_header Host      $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class="line">        proxy_connect_timeout       1;  </span><br><span class="line">        proxy_read_timeout          1;  </span><br><span class="line">        proxy_send_timeout          1;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行三个服务器程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app1.js</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server=http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.end(<span class="string">'this is node.js server 1 \n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// app2.js</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server=http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.end(<span class="string">'this is node.js server 2 \n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// app3.js</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server=http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.end(<span class="string">'this is node.js server 3 \n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# curl 192.168.1.36</span><br><span class="line">this is node.js server 1 </span><br><span class="line">[root@localhost nginx]# curl 192.168.1.36</span><br><span class="line">this is node.js server 1 </span><br><span class="line">[root@localhost nginx]# curl 192.168.1.36</span><br><span class="line">this is node.js server 2</span><br><span class="line">[root@localhost nginx]# curl 192.168.1.36</span><br><span class="line">this is node.js server 2</span><br><span class="line">[root@localhost nginx]# curl 192.168.1.36</span><br><span class="line">this is node.js server 3</span><br><span class="line">[root@localhost nginx]# curl 192.168.1.36</span><br><span class="line">this is node.js server 3</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/06/nginx/2018-08-06-Nginx负载均衡/" data-id="cjpduyils003ckqcpyths1owa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-07-28-Nginx反向代理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/28/nginx/2018-07-28-Nginx反向代理/" class="article-date">
  <time datetime="2018-07-27T16:00:00.000Z" itemprop="datePublished">2018-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/28/nginx/2018-07-28-Nginx反向代理/">Nginx反向代理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理介绍见<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">百度百科</a></p>
<h2 id="使用“反向代理服务器”的优点"><a href="#使用“反向代理服务器”的优点" class="headerlink" title="使用“反向代理服务器”的优点"></a>使用“反向代理服务器”的优点</h2><ul>
<li>反向代理服务器可以隐藏源服务器的存在和特征。</li>
<li>它充当互联网云和web服务器之间的中间层。</li>
<li>这对于安全方面来说是很好的，特别是当您使用web托管服务时。</li>
</ul>
<h2 id="Nginx实现反向代理"><a href="#Nginx实现反向代理" class="headerlink" title="Nginx实现反向代理"></a>Nginx实现反向代理</h2><p>具体见<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">官方文档</a><br>指令很多，根据自己情况来定</p>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><ol>
<li><p>Nginx配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; </span><br><span class="line">    server_name 192.168.1.36;</span><br><span class="line"></span><br><span class="line">    location / &#123; </span><br><span class="line">        proxy_pass       http://localhost:8000;</span><br><span class="line">        proxy_set_header Host      $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里我们用Node.js 创建一个简单的业务服务器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server=http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'this is node.js server\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问,无论访问80端口还是8000端口都可以访问到</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]<span class="comment"># curl http://localhost:80</span></span><br><span class="line">this is node.js server</span><br><span class="line">[root@localhost nginx]<span class="comment"># curl http://localhost:8000</span></span><br><span class="line">this is node.js server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="proxy-pass-URL"><a href="#proxy-pass-URL" class="headerlink" title="proxy_pass URL;"></a>proxy_pass URL;</h2><p>设置代理服务器的协议和地址以及应映射位置的可选URI。</p>
<p>可以指定“ http”或“ https”。</p>
<p>可以将地址指定为域名或IP地址，以及可选端口</p>
<h2 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h2><p>允许将字段重新定义或附加到传递给代理服务器的请求标头 。</p>
<p>该value可以包含文本，变量，以及它们的组合。</p>
<p>当且仅当proxy_set_header 在当前级别上没有定义指令时，这些指令才从先前级别继承 。</p>
<p>默认情况下，只重新定义了两个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Host       $proxy_host;</span><br><span class="line">proxy_set_header Connection close;</span><br></pre></td></tr></table></figure></p>
<h2 id="X-Real-IP-或-X-Forwarded-For"><a href="#X-Real-IP-或-X-Forwarded-For" class="headerlink" title="X-Real-IP 或 X-Forwarded-For"></a>X-Real-IP 或 X-Forwarded-For</h2><p>参考(<a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="noopener">https://imququ.com/post/x-forwarded-for-header-in-http.html</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/07/28/nginx/2018-07-28-Nginx反向代理/" data-id="cjpduyilr003akqcpz364pj87" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-07-05-Nginx设置https" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/05/nginx/2018-07-05-Nginx设置https/" class="article-date">
  <time datetime="2018-07-04T16:00:00.000Z" itemprop="datePublished">2018-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/05/nginx/2018-07-05-Nginx设置https/">Nginx设置https</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a>SSL 和 TLS</h2><p>SSL（Socket Secure Layer 缩写）是一种通过 HTTP 提供安全连接的协议。</p>
<p>SSL 1.0 由 Netscape 开发，但由于严重的安全漏洞从未公开发布过。SSL 2.0 于 1995 年发布，它存在一些问题，导致了最终的 SSL 3.0 在 1996 年发布。</p>
<p>TLS（Transport Layer Security 缩写）的第一个版本是作为 SSL 3.0 的升级版而编写的。之后 TLS 1.1 和 1.2 出来了。现在，就在不久之后，TLS 1.3 即将推出（这确实值得期待），并且已经被一些浏览器所支持。</p>
<p>从技术上讲，SSL 和 TLS 是不同的（因为每个协议都描述了协议的不同版本），但其中使用的许多名称是可以互换的。</p>
<h2 id="基本-SSL-TLS-配置"><a href="#基本-SSL-TLS-配置" class="headerlink" title="基本 SSL/TLS 配置"></a>基本 SSL/TLS 配置</h2><p>为了处理 HTTPS 流量，你需要具有 SSL/TLS 证书。你可以通过使用 Let’s encrypt 以生成免费的证书。</p>
<p>当你拥有证书之后，你可以通过以下的方式轻易切换至 HTTPS：</p>
<ul>
<li>开始监听端口 443（当你输入 <a href="https://sample.co" target="_blank" rel="noopener">https://sample.co</a> 时浏览器将使用的默认端口）</li>
<li>提供证书及其密钥<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl default_server;</span><br><span class="line">  listen [::]:443 ssl default_server;</span><br><span class="line"></span><br><span class="line">  ssl_certificate /etc/nginx/ssl/netguru.crt;</span><br><span class="line">  ssl_certificate_key /etc/nginx/ssl/netguru.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们也想通过调整配置实现：</p>
<ul>
<li>仅使用 TLS 协议。由于众所周知的漏洞，所有的 SSL 版本都将不再使用</li>
<li>使用预定义的安全的服务器密码（类似于协议的情况 - 那些日子只有少数密码被认为是安全的）</li>
</ul>
<p>请牢记，上述设置总是在变化的。时不时重新更新是个好主意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:!MD5;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl default_server;</span><br><span class="line">  listen [::]:443 ssl default_server;</span><br><span class="line"></span><br><span class="line">  ssl_certificate /etc/nginx/ssl/netguru.crt;</span><br><span class="line">  ssl_certificate_key /etc/nginx/ssl/netguru.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="TLS-会话恢复"><a href="#TLS-会话恢复" class="headerlink" title="TLS 会话恢复"></a>TLS 会话恢复</h2><p>使用 HTTPS，在 TCP 之上需要增加 TLS 握手。这大大增加了此前实际数据传输的时间。假设你从华沙请求 /image.jpg，并接入到柏林最近的服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Open connection</span><br><span class="line"></span><br><span class="line">TCP Handshake:</span><br><span class="line">Warsaw  -&gt;------------------ synchronize packet (SYN) -----------------&gt;- Berlin</span><br><span class="line">Warsaw  -&lt;--------- synchronise-acknowledgement packet (SYN-ACK) ------&lt;- Berlin</span><br><span class="line">Warsaw  -&gt;------------------- acknowledgement (ACK) -------------------&gt;- Berlin</span><br><span class="line"></span><br><span class="line">TLS Handshake:</span><br><span class="line">Warsaw  -&gt;------------------------ Client Hello  ----------------------&gt;- Berlin</span><br><span class="line">Warsaw  -&lt;------------------ Server Hello + Certificate ---------------&lt;- Berlin</span><br><span class="line">Warsaw  -&gt;---------------------- Change Ciper Spec --------------------&gt;- Berlin</span><br><span class="line">Warsaw  -&lt;---------------------- Change Ciper Spec --------------------&lt;- Berlin</span><br><span class="line"></span><br><span class="line">Data transfer:</span><br><span class="line">Warsaw  -&gt;---------------------- /image.jpg ---------------------------&gt;- Berlin</span><br><span class="line">Warsaw  -&lt;--------------------- (image data) --------------------------&lt;- Berlin</span><br><span class="line"></span><br><span class="line">Close connection</span><br></pre></td></tr></table></figure></p>
<p>为了在 TLS 握手期间节省一个 roundtrip 时间，以及生成新密钥的计算开销，我们可以重用在第一个请求期间生成的会话参数。客户端和服务器可以将会话参数存储在会话 ID 密钥的后面。在接下来的 TLS 握手过程中，客户端可以发送会话 ID，如果服务器在缓存中仍然有正确的条目，那么会重用前一个会话所生成的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 1h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h2><p>SSL 证书可以随时撤销。浏览器为了知道给定的证书是否不再有效，需要通过在线证书状态协议 (Online Certificate Status Protocol ，OCSP) 执行额外的查询。无需用户执行指定的 OCSP 查询，我们可以在服务器上执行此操作，缓存其结果，并在 TLS 握手期间为客户端提供 OCSP 响应。它被称为OCSP stapling。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ssl_stapling on;</span><br><span class="line">  ssl_stapling_verify on;                               # verify OCSP response</span><br><span class="line">  ssl_trusted_certificate /etc/nginx/ssl/lemonfrog.pem; # tell nginx location of all intermediate certificates</span><br><span class="line"></span><br><span class="line">  resolver 8.8.8.8 8.8.4.4 valid=86400s;                # resolution of the OCSP responder hostname</span><br><span class="line">  resolver_timeout 5s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Security-headers"><a href="#Security-headers" class="headerlink" title="Security headers"></a>Security headers</h2><p>有一些标头确实值得调整以提供更高的安全性。有关更多关于标头及其详细信息，你绝对应该查看OWASP 项目之安全标头。</p>
<h3 id="HTTP-Strict-Transport-Security"><a href="#HTTP-Strict-Transport-Security" class="headerlink" title="HTTP Strict-Transport-Security"></a>HTTP Strict-Transport-Security</h3><p>或简称 HSTS，强制用户代理在向源发送请求时使用 HTTPS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubdomains; preload&quot;;</span><br></pre></td></tr></table></figure></p>
<h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p>表示浏览器是否需要在一帧、一个 iframe 或一个对象标签中渲染页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Frame-Options DENY;</span><br></pre></td></tr></table></figure></p>
<h2 id="X-Content-Type-Options"><a href="#X-Content-Type-Options" class="headerlink" title="X-Content-Type-Options"></a>X-Content-Type-Options</h2><p>此选项将阻止浏览器在判断文件类型时嗅探文件。文件将会按照 Content-Type 头中声明的格式转译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Content-Type-Options nosniff;</span><br></pre></td></tr></table></figure></p>
<h3 id="Server-tokens"><a href="#Server-tokens" class="headerlink" title="Server tokens"></a>Server tokens</h3><p>另一个很好的做法是在 HTTP 响应头字段中隐藏有关 Web 服务器的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server : nginx/1.13.2</span><br></pre></td></tr></table></figure></p>
<p>实现此功能可以通过禁用 server_tokens 指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_tokens off;</span><br></pre></td></tr></table></figure></p>
<h2 id="附录-Let’s-Encrypt"><a href="#附录-Let’s-Encrypt" class="headerlink" title="附录 :: Let’s Encrypt"></a>附录 :: Let’s Encrypt</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>最新的安装包可以在这里找到。</p>
<p>为了测试使用暂存环境，不排除速率限制。</p>
<h3 id="生成新证书"><a href="#生成新证书" class="headerlink" title="生成新证书"></a>生成新证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --webroot --webroot-path /var/www/netguru/current/public/  \</span><br><span class="line">          -d foo.netguru.co \</span><br><span class="line">          -d bar.netguru.co</span><br></pre></td></tr></table></figure>
<p>确保能够正确更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --dry-run</span><br></pre></td></tr></table></figure></p>
<p>确保你在 crontab 添加了自动更新。运行 crontab -e，同时添加下边一行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 * * * /usr/bin/certbot renew --quiet --renew-hook &quot;/usr/sbin/nginx -s reload&quot;</span><br></pre></td></tr></table></figure></p>
<p>检查 SSL 是否能够通过 ssllabs 正常运行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/07/05/nginx/2018-07-05-Nginx设置https/" data-id="cjpduyilr0038kqcps9j6i44k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-06-16-Nginx重写rewrite" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/16/nginx/2018-06-16-Nginx重写rewrite/" class="article-date">
  <time datetime="2018-06-15T16:00:00.000Z" itemprop="datePublished">2018-06-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/16/nginx/2018-06-16-Nginx重写rewrite/">Nginx重写rewrite</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>rewrite 用于使用正则表达式更改请求URI，返回重定向，以及有条件地选择配置。参见<a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">文档</a></p>
<p>有多个配置命令：</p>
<ul>
<li>if</li>
<li>break</li>
<li>return</li>
<li>rewrite</li>
<li>set </li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>条件可以是以下任何一种：</p>
<ol>
<li>变量名; 如果变量的值为空字符串或“ 0”，则为false ;</li>
<li>使用“=”和“ !=”运算符比较变量和字符串;</li>
<li>使用“~”对于区分大小写的正则匹配</li>
<li>使用“~*”对于不区分大小写的正则匹配<ul>
<li>将变量与正则表达式进行匹配。正则表达式可以后向应用，$1.. $9变量中重用。</li>
<li>负操作符“ !~”和“ !~*”也可用。</li>
<li>如果正则表达式包含“{}”或“ ;”字符，则整个表达式应包含在单引号或双引号中。</li>
</ul>
</li>
<li>使用“ -f”和“ !-f”运算符检查文件是否存在;</li>
<li>使用“ -d”和“ !-d”运算符检查目录是否存在;</li>
<li>使用“ -e”和“ !-e”运算符检查文件，目录或符号链接是否存在;</li>
<li>使用“ -x”和“ !-x”运算符检查可执行文件。</li>
</ol>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line">&#125;</span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>停止处理当前的重写指令 。因为会发生循环重写</p>
<p>如果在该位置内指定了指令，则在该 位置继续进一步处理该请求。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果ie浏览器，单独拿出来处理，不加break就会循环在这里。</p>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return code [text];</span><br><span class="line">return code URL;</span><br><span class="line">return URL;</span><br></pre></td></tr></table></figure>
<p>停止处理并将指定的内容返回code给客户端。</p>
<p>可以指定重定向URL（对于代码301,302,303,307和308）或响应正文text（对于其他代码）</p>
<p>一般配合if使用</p>
<h2 id="rewrite-1"><a href="#rewrite-1" class="headerlink" title="rewrite"></a>rewrite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement [flag];</span><br></pre></td></tr></table></figure>
<p>如果指定的正则表达式与请求URI匹配，则URI将根据replacement字符串中的指定进行更改。该rewrite指令在其在配置文件中出现的顺序顺序地执行。可以使用标志终止对指令的进一步处理。如果替换字符串以“ http://”，“ https://”或“ $scheme” 开头，则处理停止并将重定向返回给客户端。</p>
<p>可选flag参数可以是以下之一：</p>
<ul>
<li>last<ul>
<li>停止处理当前的ngx_http_rewrite_module指令集 并开始搜索与更改的URI匹配的新位置;</li>
</ul>
</li>
<li>break<ul>
<li>ngx_http_rewrite_module与break指令一样， 停止处理当前的指令集 ;</li>
</ul>
</li>
<li>redirect<ul>
<li>返回带有302代码的临时重定向; 如果替换字符串不以“ http://”，“ https://”或“ $scheme” 开头，则使用;</li>
</ul>
</li>
<li>permanent<ul>
<li>返回301代码的永久重定向。</li>
</ul>
</li>
</ul>
<p>完整重定向URL根据请求scheme（$scheme）和 server_name_in_redirect以及 port_in_redirect指令形成。</p>
<p>例：像/download/language/en/audio/class1/less1.ogg  路径变成  /download/language/en/mp3/class1/less1.ra<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;</span><br><span class="line">    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;</span><br><span class="line">    return  403;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果将这些指令放在“ /download/”位置内，则该last标志应替换为 break，否则nginx将进行10次循环并返回500错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break;</span><br><span class="line">    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  break;</span><br><span class="line">    return  403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果replacement字符串包含新的请求参数，则先前的请求参数将附加在它们之后。如果这是不希望的，在替换字符串的末尾加上一个问号可以避免附加它们，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^/users/(.*)$ /show?user=$1? last;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $variable value;</span><br></pre></td></tr></table></figure>
<p>set 是设置变量用的, 可以用来达到多条件判断时作标志用.<br>例如：判断IE并重写,且不用break; 我们用set变量来达到目的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~* msie) &#123;</span><br><span class="line">  set $isie 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($fastcgi_script_name = ie.html) &#123;</span><br><span class="line">  set $isie 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($isie 1) &#123;</span><br><span class="line">  rewrite ^.*$ ie.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/06/16/nginx/2018-06-16-Nginx重写rewrite/" data-id="cjpduyilq0036kqcp1w7gzt0e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-06-08-Nginx定位location" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/08/nginx/2018-06-08-Nginx定位location/" class="article-date">
  <time datetime="2018-06-07T16:00:00.000Z" itemprop="datePublished">2018-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/nginx/2018-06-08-Nginx定位location/">Nginx定位location</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>location 有”定位”的意思, 根据Uri来进行不同的定位.</p>
<p>在虚拟主机的配置中,是必不可少的,location可以把网站的不同部分,定位到不同的处理方式上.</p>
<p>比如, 碰到.png, 如何获取到图片?<br>–这时就需要location</p>
<h2 id="location-语法"><a href="#location-语法" class="headerlink" title="location 语法"></a>location 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] pattern &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>中括号可以不写任何参数,此时称为一般匹配, 则路径被视为前缀，其后可以跟随任何东西。</li>
<li>也可以写参数</li>
</ol>
<p>因此,大类型可以分为3种:</p>
<ol>
<li><code>location = patt {}</code> 精准匹配</li>
<li><code>location patt {}</code>  一般匹配</li>
<li><code>location ~ patt{}</code> 正则匹配</li>
</ol>
<h2 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">location</span> = /login.html &#123;</span><br><span class="line">  root /var/account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当访问<code>curl localhost/login.html</code>时，会找<code>/var/account/login.html</code>这个文件</p>
<h2 id="一般匹配"><a href="#一般匹配" class="headerlink" title="一般匹配"></a>一般匹配</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">  root /var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当url路径是/images开头的都会访问/var/images目录</p>
<p>以上栗子将匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hostname:port/images/logo.jpg</span><br><span class="line">hostname:port/images/home/home.png</span><br><span class="line">hostname:port/imagesdir</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/(javascript|js)/  &#123;</span><br><span class="line">  root   /var/js;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当url路径是 /javascript 或者 /js 开头的都会访问/var/js目录</p>
<h2 id="如果混用，该怎么办？"><a href="#如果混用，该怎么办？" class="headerlink" title="如果混用，该怎么办？"></a>如果混用，该怎么办？</h2><p>匹配过程是按照配置文件从上而下进行的</p>
<ol>
<li>如果被精准匹配到,则停止匹配，不管之前是否有一般或者正则匹配</li>
<li>如果整个匹配过程走完没有被精准匹配到，而被正则匹配到，就用第一个匹配的</li>
<li>如果既没有被精准匹配到，也没有被正则匹配到，而被一般匹配到了，看谁匹配的最长，用最长的</li>
<li>都没有匹配上，404</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/06/08/nginx/2018-06-08-Nginx定位location/" data-id="cjpduyilp0034kqcpq6vsabzd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-05-28-Nginx日志管理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/28/nginx/2018-05-28-Nginx日志管理/" class="article-date">
  <time datetime="2018-05-27T16:00:00.000Z" itemprop="datePublished">2018-05-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/28/nginx/2018-05-28-Nginx日志管理/">Nginx日志管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>Nginx的日在配置在http块和server块中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表明Nginx的访问日志在Nginx安装目录下的logs文件夹下，使用main格式</p>
<p>http块是全局的，server块的日志是此虚拟主机专用的</p>
<h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>日志默认格式定义在http块下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些都Nginx内置定义的一些正则表达式，定义在conf/fastcgi.conf文件中<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line">...</span><br><span class="line">fastcgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">fastcgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">fastcgi_param  SERVER_ADDR        $server_addr;</span><br><span class="line">fastcgi_param  SERVER_PORT        $server_port;</span><br><span class="line">fastcgi_param  SERVER_NAME        $server_name;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>log格式可以自定义，包括可以定义成json的形式。需要一个<a href="https://github.com/jiaz/nginx-http-json-log" target="_blank" rel="noopener">nginx-http-json-log插件</a></p>
<h2 id="日志按天分割"><a href="#日志按天分割" class="headerlink" title="日志按天分割"></a>日志按天分割</h2><p>实际上，日志是要按时间这样分割的，易于管理。之前讲到Nginx有重新载入日志的信号<code>nginx -s reopen</code>，这里可以写歌shell脚本每天定时分割日志：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">logs_path=/usr/<span class="built_in">local</span>/nginx/logs</span><br><span class="line">mounth=$( date -d yesterday +<span class="string">"%Y%m"</span> )</span><br><span class="line">day=$( date -d yesterday +<span class="string">"%d"</span> )</span><br><span class="line">mkdir -p <span class="variable">$logs_path</span>/<span class="variable">$mounth</span></span><br><span class="line">mv <span class="variable">$logs_path</span>/access.log <span class="variable">$logs_path</span>/<span class="variable">$mountth</span>/<span class="variable">$day_access</span>.<span class="built_in">log</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reopen</span><br></pre></td></tr></table></figure></p>
<p>Linux系统下的定时任务用 crontab 工具 ， 每天0时1分运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 00 * * * /usr/local/nginx/script/log_split.sh</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/05/28/nginx/2018-05-28-Nginx日志管理/" data-id="cjpduyilo0031kqcp1k8mx6an" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-05-20-Nginx虚拟主机配置" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/20/nginx/2018-05-20-Nginx虚拟主机配置/" class="article-date">
  <time datetime="2018-05-19T16:00:00.000Z" itemprop="datePublished">2018-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/20/nginx/2018-05-20-Nginx虚拟主机配置/">Nginx虚拟主机配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><ul>
<li>在 Nginx 内部，你可以指定多个虚拟主机</li>
<li>每个虚拟主机用 server{} 上下文描述</li>
</ul>
<h2 id="基于域名的虚拟主机"><a href="#基于域名的虚拟主机" class="headerlink" title="基于域名的虚拟主机"></a>基于域名的虚拟主机</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.test.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/test.com;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen      *:80 default_server;</span><br><span class="line">  server_name test.com;</span><br><span class="line">  return 200 "Hello from test.com";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen      *:80;</span><br><span class="line">  server_name demo.com;</span><br><span class="line">  return 200 "Hello from demo.com";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h2><p>server_name指令接受多个值。它还处理通配符匹配和正则表达式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name test.com www.test.com; # exact match</span><br><span class="line">server_name *.test.com;              # wildcard matching</span><br><span class="line">server_name test.*;                 # wildcard matching</span><br><span class="line">server_name  ~^[0-9]*\.netguru\.co$;   # regexp matching</span><br></pre></td></tr></table></figure></p>
<p>当有歧义时，nginx 将使用下面的命令：</p>
<ol>
<li>确切的名字</li>
<li>最长的通配符名称以星号开始，例如“* .example.org”。</li>
<li>最长的通配符名称以星号结尾，例如“mail.**”</li>
<li>首先匹配正则表达式（按照配置文件中的顺序）</li>
</ol>
<p>Nginx 会存储 3 个哈希表：确切的名字，以星号开始的通配符，和以星号结尾的通配符。如果结果不在任何表中，则将按顺序进行正则表达式测试。</p>
<p>值得谨记的是</p>
<p><code>server_name .test.com;</code></p>
<p>是一个来自下面的缩写</p>
<p><code>server_name  test.com  www.test.com  *.test.com;</code></p>
<p>有一点不同，.test.com 存储在第二张表，这意味着它比显式声明的慢一点。</p>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>在很多情况下，能够找到 listen 指令，接受IP:端口值<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen 127.0.0.1:80;</span><br><span class="line">listen 127.0.0.1;    # by default port :80 is used</span><br><span class="line"></span><br><span class="line">listen *:81;</span><br><span class="line">listen 81;           # by default all ips are used</span><br><span class="line"></span><br><span class="line">listen [::]:80;      # IPv6 addresses</span><br><span class="line">listen [::1];        # IPv6 addresses</span><br></pre></td></tr></table></figure></p>
<p>然而，还可以指定 UNIX-domain 套接字。</p>
<p><code>listen unix:/var/run/nginx.sock;</code></p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>location / 对访问根路径进行特殊处理。详见<a href="./2018-06-08-Nginx定位location">Nginx定位location</a></p>
<h3 id="location-root"><a href="#location-root" class="headerlink" title="location.root"></a>location.root</h3><ul>
<li>root 指令设置请求的根目录，允许 nginx 将传入请求映射到文件系统。</li>
<li>使用相对路径是相对nginx的安装目录.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如</span></span><br><span class="line">www.test.com:80/index.html     # returns /var/www/test.com/index.html</span><br><span class="line">www.test.com:80/foo/index.html # returns /var/www/test.com/foo/index.html</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="location-index"><a href="#location-index" class="headerlink" title="location.index"></a>location.index</h3><p>root文件夹中具体的文件。</p>
<h2 id="Nginx-将会按照下列顺序选择虚拟主机："><a href="#Nginx-将会按照下列顺序选择虚拟主机：" class="headerlink" title="Nginx 将会按照下列顺序选择虚拟主机："></a>Nginx 将会按照下列顺序选择虚拟主机：</h2><ol>
<li>匹配sever_name指令的IP-端口主机</li>
<li>拥有default_server标记的IP-端口主机</li>
<li>首先定义的IP-端口主机</li>
<li>如果没有匹配，拒绝连接。</li>
</ol>
<h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><ol>
<li><p>先修改/etc/hosts 文件 ，添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.3.42.1  www.test.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>在/tmp 下创建目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]# mkdir -p /tmp/www/test.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is www.test.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx重新加载配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test.com]# /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]<span class="comment"># curl www.test.com</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基于端口的虚拟主机配置"><a href="#基于端口的虚拟主机配置" class="headerlink" title="基于端口的虚拟主机配置"></a>基于端口的虚拟主机配置</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name 192.168.1.204;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/html8080;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/05/20/nginx/2018-05-20-Nginx虚拟主机配置/" data-id="cjpduyilo002zkqcp9gegk0nq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-egg/2018-5-17-egg-core源码解析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/egg/2018-5-17-egg-core源码解析/" class="article-date">
  <time datetime="2018-05-16T16:00:00.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/egg/">egg</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/egg/2018-5-17-egg-core源码解析/">egg-core源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="egg-js"><a href="#egg-js" class="headerlink" title="egg.js"></a>egg.js</h2><p>egg.js是阿里开源的node.js企业级框架，它在koa上封装一层，使得开发大型应用时候方便。<a href="https://eggjs.org" target="_blank" rel="noopener">egg.js官网</a><br><img src="JFKAMfmPehWfhBPdCjrw.svg" alt="logo"></p>
<h2 id="egg-core"><a href="#egg-core" class="headerlink" title="egg-core"></a>egg-core</h2><p><a href="https://github.com/eggjs/egg-core" target="_blank" rel="noopener">egg-core</a> 是egg.js的核心代码实现的package，它导出了基于egg开发时常用的四个类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EggCore = <span class="built_in">require</span>(<span class="string">'./lib/egg'</span>);</span><br><span class="line"><span class="keyword">const</span> EggLoader = <span class="built_in">require</span>(<span class="string">'./lib/loader/egg_loader'</span>);</span><br><span class="line"><span class="keyword">const</span> BaseContextClass = <span class="built_in">require</span>(<span class="string">'./lib/utils/base_context_class'</span>);</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./lib/utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  EggCore,</span><br><span class="line">  EggLoader,</span><br><span class="line">  BaseContextClass,</span><br><span class="line">  utils,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="EggCore"><a href="#EggCore" class="headerlink" title="EggCore"></a>EggCore</h3><p><a href="https://github.com/eggjs/egg-core/blob/master/lib/egg.js" target="_blank" rel="noopener">EggCore</a> 是对koa的一个封装。如代码。它直接继承于koa:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> KoaApplication = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggCore</span> <span class="keyword">extends</span> <span class="title">KoaApplication</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = EggCore;</span><br></pre></td></tr></table></figure></p>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>EggCore的构造函数做了许多初始化的操作，比如:</p>
<ol>
<li>确定应用工作目录，一种一个作用是egg自动加载各个<a href="https://eggjs.org/zh-cn/basics/structure.html" target="_blank" rel="noopener">模块</a>的js文件；</li>
<li>确定工作进程，详情见<a href="https://eggjs.org/zh-cn/core/cluster-and-ipc.html" target="_blank" rel="noopener">多进程模型和进程间通讯</a>；</li>
<li>注册应用关闭时回调函数集合；</li>
<li>设置超时时间；</li>
<li>logger设置；</li>
<li>ctx、controller、service的基类同为BaseContextClass；</li>
<li>初始化loader；</li>
</ol>
<p>初始化做完后，就会调用<code>[INIT_READY]()</code>方法。这个方法会注册一些回调。</p>
<h3 id="Eggloader"><a href="#Eggloader" class="headerlink" title="Eggloader"></a>Eggloader</h3><p><a href="https://github.com/eggjs/egg-core/blob/master/lib/loader/egg_loader.js" target="_blank" rel="noopener">Eggloader</a><br>Loader可以说是egg的一个精华所在。详细介绍见<a href="https://eggjs.org/zh-cn/advanced/loader.html" target="_blank" rel="noopener">Loader</a>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.pkg = utility.readJSONSync(path.join(<span class="keyword">this</span>.options.baseDir, <span class="string">'package.json'</span>));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.eggPaths = <span class="keyword">this</span>.getEggPaths();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.serverEnv = <span class="keyword">this</span>.getServerEnv();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.appInfo = <span class="keyword">this</span>.getAppInfo();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.serverScope = options.serverScope !== <span class="literal">undefined</span></span><br><span class="line">      ? options.serverScope</span><br><span class="line">      : <span class="keyword">this</span>.getServerScope();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Loader的构造函数主要逻辑有</p>
<ol>
<li>读取package.json文件</li>
<li>获取所有继承与egg.Application框架的目录，loader将会加载他们。</li>
<li>获取服务环境，有test环境、local环境和production环境等。</li>
<li>获取应用信息，有appName、dir、env、scope、pkg等。</li>
<li>获取服务作用域</li>
</ol>
<p>Loader还有几个方法:</p>
<h4 id="loadFile"><a href="#loadFile" class="headerlink" title="loadFile"></a>loadFile</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadFile(filepath, ...inject) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载一个js文件，返回这个js文件的exports对象，如果exports是一个function，就会立即执行。其实底层很简单，就是用require()函数。</p>
<h4 id="getLoadUnits"><a href="#getLoadUnits" class="headerlink" title="getLoadUnits"></a>getLoadUnits</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getLoadUnits() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取所有加载的模块，包括：</p>
<ol>
<li>plugin</li>
<li>framework</li>
<li>app</li>
</ol>
<h4 id="loadToApp"><a href="#loadToApp" class="headerlink" title="loadToApp"></a>loadToApp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadToApp(directory, property, opt) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用FileLoader加载文件，挂载到egg.Application对象上。</p>
<h4 id="loadToContext"><a href="#loadToContext" class="headerlink" title="loadToContext"></a>loadToContext</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadToContext(directory, property, opt) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用loadToContext加载文件，挂载到ctx对象上。</p>
<h3 id="BaseContextClass"><a href="#BaseContextClass" class="headerlink" title="BaseContextClass"></a>BaseContextClass</h3><p><a href="https://github.com/eggjs/egg-core/blob/master/lib/utils/base_context_class.js" target="_blank" rel="noopener">BaseContextClass</a><br>这个类是所有egg的ctx、controller、service的基类，仅仅定义了构造函数，定义了一些公用的属性，有ctx、app、config和service</p>
<h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><p><a href="https://github.com/eggjs/egg-core/blob/master/lib/utils/index.js" target="_blank" rel="noopener">utils</a><br>这个类是实现egg基础的工具类，有几个方法：</p>
<h4 id="loadFile-1"><a href="#loadFile-1" class="headerlink" title="loadFile"></a>loadFile</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">loadFile(filepath) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// if not js module, just return content buffer</span></span><br><span class="line">    <span class="keyword">const</span> extname = path.extname(filepath);</span><br><span class="line">    <span class="keyword">if</span> (extname &amp;&amp; !<span class="built_in">require</span>.extensions[extname]) &#123;</span><br><span class="line">      <span class="keyword">return</span> fs.readFileSync(filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// require js module</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">require</span>(filepath);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// it's es module</span></span><br><span class="line">    <span class="keyword">if</span> (obj.__esModule) <span class="keyword">return</span> <span class="string">'default'</span> <span class="keyword">in</span> obj ? obj.default : obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = <span class="string">`[egg-core] load file: <span class="subst">$&#123;filepath&#125;</span>, error: <span class="subst">$&#123;err.message&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是上面loader.loadFile()的底层实现。</p>
<h4 id="async-callFn"><a href="#async-callFn" class="headerlink" title="async callFn"></a>async callFn</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> callFn(fn, args, ctx) &#123;</span><br><span class="line">  args = args || [];</span><br><span class="line">  <span class="keyword">if</span> (!is.function(fn)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (is.generatorFunction(fn)) fn = co.wrap(fn);</span><br><span class="line">  <span class="keyword">return</span> ctx ? fn.call(ctx, ...args) : fn(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就为了方便使用async/await调用方式的。</p>
<h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">middleware(fn) &#123;</span><br><span class="line">  <span class="keyword">return</span> is.generatorFunction(fn) ? convert(fn) : fn;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>将koa v1.x形式的generator函数转成koa v2.x 的middleware</p>
<h3 id="FileLoader"><a href="#FileLoader" class="headerlink" title="FileLoader"></a>FileLoader</h3><h4 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">  <span class="keyword">this</span>.options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaults, options);</span><br><span class="line">  <span class="comment">// compatible old options _lowercaseFirst_</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.options.lowercaseFirst === <span class="literal">true</span>) &#123;</span><br><span class="line">    deprecate(<span class="string">'lowercaseFirst is deprecated, use caseStyle instead'</span>);</span><br><span class="line">    <span class="keyword">this</span>.options.caseStyle = <span class="string">'lower'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fileLoader的构造函数仅仅初始化了options，options包括：</p>
<ul>
<li>options.directory - directories to be loaded</li>
<li>options.target - attach the target object from loaded files</li>
<li>options.match - match the files when load, support glob, default to all js files</li>
<li>options.ignore - ignore the files when load, support glob</li>
<li>options.initializer - custom file exports, receive two parameters, first is the inject object(if not js file, will be content buffer), second is an <code>options</code> object that contain <code>path</code></li>
<li>options.call - determine whether invoke when exports is function</li>
<li>options.override - determine whether override the property when get the same name</li>
<li>options.inject - an object that be the argument when invoke the function</li>
<li>options.filter - a function that filter the exports which can be loaded</li>
<li>options.caseStyle - set property’s case when converting a filepath to property list.</li>
</ul>
<p>fileLoader最主要还是load方法</p>
<h4 id="load"><a href="#load" class="headerlink" title="load"></a>load</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">load() &#123;</span><br><span class="line">  <span class="comment">// 解析所有exports组成的数组items，每一个item都包含fullpath, properties, exports，properties就是文件路径映射的属性名数组。</span></span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">this</span>.parse();</span><br><span class="line">  <span class="comment">// 被挂载的目标对象target</span></span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">this</span>.options.target;</span><br><span class="line">  <span class="comment">// 遍历items，以对象属性的形式想target上挂载。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">    debug(<span class="string">'loading item %j'</span>, item);</span><br><span class="line">    <span class="comment">// item &#123; properties: [ 'a', 'b', 'c'], exports &#125;</span></span><br><span class="line">    <span class="comment">// =&gt; target.a.b.c = exports</span></span><br><span class="line">    item.properties.reduce(<span class="function">(<span class="params">target, property, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> obj;</span><br><span class="line">      <span class="keyword">const</span> properties = item.properties.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">'.'</span>);</span><br><span class="line">      <span class="keyword">if</span> (index === item.properties.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.options.override) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`can't overwrite property '<span class="subst">$&#123;properties&#125;</span>' from <span class="subst">$&#123;target[property][FULLPATH]&#125;</span> by <span class="subst">$&#123;item.fullpath&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj = item.exports;</span><br><span class="line">        <span class="keyword">if</span> (obj &amp;&amp; !is.primitive(obj)) &#123;</span><br><span class="line">          obj[FULLPATH] = item.fullpath;</span><br><span class="line">          obj[EXPORTS] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = target[property] || &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      target[property] = obj;</span><br><span class="line">      debug(<span class="string">'loaded %s'</span>, properties);</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;, target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load方法功能就是向目标对象 挂载 文件exports出的对象，同事把文件路径映射成对象属性的形式。比如<code>app/controller/group/repository.js</code> =&gt; <code>target.group.repository</code></p>
<h3 id="ContextLoader"><a href="#ContextLoader" class="headerlink" title="ContextLoader"></a>ContextLoader</h3><p>看完FileLoader，在看ContextLoader就更简单了，ContextLoader 直接继承 FileLoader，只是构造函数加了些东西：</p>
<h4 id="constructor-1"><a href="#constructor-1" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = options.target = &#123;&#125;;</span><br><span class="line">    <span class="comment">// options.fieldClass - determine the field name of inject object.</span></span><br><span class="line">    <span class="keyword">if</span> (options.fieldClass) &#123;</span><br><span class="line">      options.inject[options.fieldClass] = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">this</span>.options.inject;</span><br><span class="line">    <span class="keyword">const</span> property = options.property;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, property, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>[CLASSLOADER]) &#123;</span><br><span class="line">          <span class="keyword">this</span>[CLASSLOADER] = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> classLoader = <span class="keyword">this</span>[CLASSLOADER];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> instance = classLoader.get(property);</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">          instance = getInstance(target, <span class="keyword">this</span>);</span><br><span class="line">          classLoader.set(property, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params">values, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Class = values[EXPORTS] ? values : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (Class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.class(Class)) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Class(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      instance = Class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(values)) &#123;</span><br><span class="line">    instance = values;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> ClassLoader(&#123; ctx, <span class="attr">properties</span>: values &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，构造函数额外的用<code>Object.defineProperty()</code>方法向<code>app.context</code>上定义了<code>getter</code>,当每次访问时候，就会从缓存中拿到classLoader，再用classLoader获取所需要的对象，这里有懒加载形式。看看classLoader实现：</p>
<h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> properties = options.properties;</span><br><span class="line">    <span class="keyword">this</span>._cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">this</span>._ctx = options.ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">in</span> properties) &#123;</span><br><span class="line">      <span class="comment">// 定义getter，</span></span><br><span class="line">      <span class="keyword">this</span>.defineProperty(property, properties[property]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defineProperty(property, values) &#123;</span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, property, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        <span class="comment">// 从_cache中获取instance</span></span><br><span class="line">        <span class="keyword">let</span> instance = <span class="keyword">this</span>._cache.get(property);</span><br><span class="line">        <span class="comment">// 如果instance为null</span></span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">          <span class="comment">// 得到instance</span></span><br><span class="line">          instance = getInstance(values, <span class="keyword">this</span>._ctx);</span><br><span class="line">          <span class="comment">// 把instance放入_cache</span></span><br><span class="line">          <span class="keyword">this</span>._cache.set(property, instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassLoader就是相当与一个代理，当访问一个属性时候，其实最终到访问到classloader中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>egg的精华所在就在loader这里，这里我仅仅粗浅的认识下，还需要更深入的学习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/05/17/egg/2018-5-17-egg-core源码解析/" data-id="cjpduyin6006ekqcp07vlgu7d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-05-11-Nginx全局配置" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/11/nginx/2018-05-11-Nginx全局配置/" class="article-date">
  <time datetime="2018-05-10T16:00:00.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/11/nginx/2018-05-11-Nginx全局配置/">Nginx配置文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="nnginx-的配置文件"><a href="#nnginx-的配置文件" class="headerlink" title="nnginx 的配置文件"></a>nnginx 的配置文件</h2><p>默认的位置包括：</p>
<ul>
<li>/etc/nginx/nginx.conf</li>
<li>/usr/local/etc/nginx/nginx.conf</li>
<li>/usr/local/nginx/conf/nginx.conf</li>
</ul>
<p>打开nginx.conf可看到入下结构<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    use epoll;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123; </span><br><span class="line">        location &#123; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="user-nobody"><a href="#user-nobody" class="headerlink" title="user  nobody"></a>user  nobody</h2><p>nobody在linux中是一个不能登陆的帐号，一些服务进程如apache，aquid等都采用一些特殊的帐号来运行，这是就可以防止程序本身有安全问题的时候，不会被黑客获得root权限</p>
<p>这个选项一定程度上保证了服务器安全性，</p>
<h2 id="worker-processes-1"><a href="#worker-processes-1" class="headerlink" title="worker_processes 1"></a>worker_processes 1</h2><p>定义工作的子进程数量,可以自行修改,但太大无益,因为要争夺CPU,一般设置为 CPU数*核数</p>
<h2 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h2><p>错误日志的存放路径，默认是在安装目录的logs下, 可以根据日志级别存放不同文件中。</p>
<p>error_log 级别分为 debug, info, notice, warn, error, crit  默认为crit</p>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><p>存放Nginx运行时的pid信息的文件，默认也是放在logs下</p>
<h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>events块中的 worker_connections定义一个子进程最大允许连接数量，按需定义。定义 4096 能应付大部分公司需求。<br>use kqueue;定义连接处理方法有：[ kqueue | rtsig | epoll | /dev/poll | select | poll ] 详见<a href="http://nginx.org/en/docs/events.html" target="_blank" rel="noopener">Connection processing methods</a></p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http块是用来配置http服务器信息的。http.server是定义这是虚拟主机段<br>http.server.location是用来处理特殊路径的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/05/11/nginx/2018-05-11-Nginx全局配置/" data-id="cjpduyiln002wkqcprchvqezw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/egg/">egg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs-yaml/">nodejs yaml</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/request/">request</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lodash/">lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/koa/" style="font-size: 15px;">koa</a> <a href="/tags/lodash/" style="font-size: 20px;">lodash</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/28/egg/egg-特性/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/">Nginx性能优化之Keep-Alive</a>
          </li>
        
          <li>
            <a href="/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/">Nginx性能优化之Buffers</a>
          </li>
        
          <li>
            <a href="/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/">Nginx性能优化之超时</a>
          </li>
        
          <li>
            <a href="/2018/08/30/nginx/2018-08-30-Nginx性能优化之缓存/">Nginx性能优化之缓存</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Jax<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>