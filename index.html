<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>蓦然回首，bug依然在灯火阑珊处</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta name="keywords" content="后端 Node.js go golang">
<meta property="og:type" content="website">
<meta property="og:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:url" content="http://yacen.github.io/index.html">
<meta property="og:site_name" content="蓦然回首，bug依然在灯火阑珊处">
<meta property="og:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
<meta property="og:locale" content="Zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓦然回首，bug依然在灯火阑珊处">
<meta name="twitter:description" content="记录一些资料，有原创也有摘录，防止以后会忘记。">
  
    <link rel="alternate" href="/atom.xml" title="蓦然回首，bug依然在灯火阑珊处" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蓦然回首，bug依然在灯火阑珊处</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录平时可能用到的资料</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yacen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-egg/egg-特性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/28/egg/egg-特性/" class="article-date">
  <time datetime="2018-11-28T08:50:25.687Z" itemprop="datePublished">2018-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/11/28/egg/egg-特性/" data-id="cjpi4wnz20004f9cp87vyq6or" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-09-20-Nginx错误之13Permission denied" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/20/nginx/2018-09-20-Nginx错误之13Permission denied/" class="article-date">
  <time datetime="2018-09-19T16:00:00.000Z" itemprop="datePublished">2018-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/20/nginx/2018-09-20-Nginx错误之13Permission denied/">Nginx错误之13:Permission denied</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="条件不允许的情况下（不能随意重启计算机）执行下列代码："><a href="#条件不允许的情况下（不能随意重启计算机）执行下列代码：" class="headerlink" title="条件不允许的情况下（不能随意重启计算机）执行下列代码："></a>条件不允许的情况下（不能随意重启计算机）执行下列代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect 1</span><br></pre></td></tr></table></figure>
<h2 id="其他情况下获取root权限"><a href="#其他情况下获取root权限" class="headerlink" title="其他情况下获取root权限"></a>其他情况下获取root权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure>
<p>找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=enforcing</span><br></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure></p>
<p>更多setbool的使用查看<br><a href="http://blog.chinaunix.net/uid-26727991-id-3235275.html" target="_blank" rel="noopener">setsebool命令和设置命令</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/09/20/nginx/2018-09-20-Nginx错误之13Permission denied/" data-id="cjpi4wo0q003wf9cpudg1g1oo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-09-12-Nginx性能优化之Keep-Alive" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/" class="article-date">
  <time datetime="2018-09-11T16:00:00.000Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/">Nginx性能优化之Keep-Alive</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><p>HTTP 所依赖的 TCP 协议需要执行三次握手来启动连接。这意味着在服务器可发送数据（例如图像）之前，需要在客户机和服务器之间进行三次完整的往返。</p>
<p>假设你从 Warsaw 请求的 /image.jpg，并连接到在柏林最近的服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Open connection</span><br><span class="line"></span><br><span class="line">TCP Handshake:</span><br><span class="line">Warsaw  -&gt;------------------ synchronize packet (SYN) -----------------&gt;- Berlin</span><br><span class="line">Warsaw  -&lt;--------- synchronise-acknowledgement packet (SYN-ACK) ------&lt;- Berlin</span><br><span class="line">Warsaw  -&gt;------------------- acknowledgement (ACK) -------------------&gt;- Berlin</span><br><span class="line"></span><br><span class="line">Data transfer:</span><br><span class="line">Warsaw  -&gt;---------------------- /image.jpg ---------------------------&gt;- Berlin</span><br><span class="line">Warsaw  -&lt;--------------------- (image data) --------------------------&lt;- Berlin</span><br><span class="line"></span><br><span class="line">Close connection</span><br></pre></td></tr></table></figure></p>
<p>对于另一次请求，你将不得不再次执行整个初始化。如果你在短时间内发送多次请求，这可能会快速累积起来。这样的话 keep-alive 使用起来就方便了。在成功响应之后，它保持连接空闲给定的时间段（例如 10 秒）。如果在这段时间内有另一个请求，现有的连接将被重用，空闲时间将被刷新。</p>
<p>Nginx 提供了几个指令来调整 keepalive 设置。这些可以分为两类：</p>
<ul>
<li><p>在客户端和 nginx 之间 keep-alive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keepalive_disable msie6;        # disable selected browsers.</span><br><span class="line"></span><br><span class="line"># The number of requests a client can make over a single keepalive connection. The default is 100, but a much higher value can be especially useful for testing with a load‑generation tool, which generally sends a large number of requests from a single client.</span><br><span class="line">keepalive_requests 100000;</span><br><span class="line"></span><br><span class="line"># How long an idle keepalive connection remains open.</span><br><span class="line">keepalive_timeout 60;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 nginx 和上游服务器之间 keep-alive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    # The number of idle keepalive connections to an upstream server that remain open for each worker process</span><br><span class="line">    keepalive 16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  location /http/ &#123;</span><br><span class="line">    proxy_pass http://http_backend;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Connection &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="问题现象：-一个JSP页面，居然要耗时40多秒。网页中有大量的图片的CSS"><a href="#问题现象：-一个JSP页面，居然要耗时40多秒。网页中有大量的图片的CSS" class="headerlink" title="问题现象： 一个JSP页面，居然要耗时40多秒。网页中有大量的图片的CSS"></a>问题现象： 一个JSP页面，居然要耗时40多秒。网页中有大量的图片的CSS</h2><p>问题解决： 原因也找了半天，原来Apache配置里面，把Keep-Alive的开关关闭了。</p>
<p>这个是个大问题，工程师为什么要关闭它，原来他考虑的太简单了，我们知道Apache适合处于短连接的请求，处理时间越短，并发数才能上去，原来他是这么考虑，但是没有办法，只能这样了，还是打开Keep-Alive开关吧。</p>
<p>当然，不是所有的情况都设置KeepAlive为On，下面的文字总结比较好：</p>
<p>在使用apache的过程中，KeepAlive属性我一直保持为默认值On，其实，该属性设置为On还是Off还是要具体问题具体分析的，在生产环境中的影响还是蛮大的。</p>
<p>KeepAlive选项到底有什么用处？<br>如果你用过Mysql ，应该知道Mysql的连接属性中有一个与KeepAlive 类似的Persistent Connection，即：长连接(PConnect)。该属性打开的话，可以使一次TCP连接为同一用户的多次请求服务，提高了响应速度。</p>
<p>比如很多网页中图片、CSS、JS、Html都在一台Server上，当用户访问其中的Html网页时，网页中的图片、Css、Js都构成了访问请求，打开KeepAlive 属性可以有效地降低TCP握手的次数(当然浏览器对同一域下同时请求的图片数有限制，一般是2 见下文章节 减少域名解释的开销)，减少httpd进程数，从而降低内存的使用(假定prefork模式)。MaxKeepAliveRequests 和KeepAliveTimeOut 两个属性在KeepAlive =On时起作用，可以控制持久连接的生存时间和最大服务请求数。</p>
<p>不过，上面说的只是一种情形，那就是<em>静态网页</em>居多的情况下，并且网页中的其他请求与网页在同一台Server上。当你的应用动态程序(比如：php )居多，用户访问时由动态程序即时生成html内容，html内容中图片素材和Css、Js等比较少或者散列在其他Server上时，KeepAlive =On反而会降低Apache 的性能。为什么呢？</p>
<p>前面提到过，KeepAlive =On时，每次用户访问，打开一个TCP连接，Apache 都会保持该连接一段时间，以便该连接能连续为同一client服务，在KeepAliveTimeOut还没到期并且MaxKeepAliveRequests还没到阈值之前，Apache 必然要有一个httpd进程来维持该连接，httpd进程不是廉价的，他要消耗内存和CPU时间片的。假如当前Apache 每秒响应100个用户访问，KeepAliveTimeOut=5，此时httpd进程数就是100<em>5=500个(prefork 模式)，一个httpd进程消耗5M内存的话，就是500</em>5M=2500M=2.5G，夸张吧？当然，Apache 与Client只进行了100次TCP连接。如果你的内存够大，系统负载不会太高，如果你的内存小于2.5G，就会用到Swap，频繁的Swap切换会加重CPU的Load。</p>
<p>现在我们关掉KeepAlive ，Apache 仍然每秒响应100个用户访问，因为我们将图片、js、css等分离出去了，每次访问只有1个request，此时httpd的进程数是100<em>1=100个，使用内存100</em>5M=500M，此时Apache 与Client也是进行了100次TCP连接。性能却提升了太多。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>当你的Server内存充足时，KeepAlive =On还是Off对系统性能影响不大。</li>
<li>当你的Server上静态网页(Html、图片、Css、Js)居多时，建议打开KeepAlive 。</li>
<li>当你的Server多为动态请求(因为连接数据库，对文件系统访问较多)，KeepAlive 关掉，会节省一定的内存，节省的内存正好可以作为文件系统的Cache(vmstat命令中cache一列)，降低I/O压力。</li>
</ol>
<p>PS：当KeepAlive =On时，KeepAliveTimeOut的设置其实也是一个问题，设置的过短，会导致Apache 频繁建立连接，给Cpu造成压力，设置的过长，系统中就会堆积无用的Http连接，消耗掉大量内存，具体设置多少，可以进行不断的调节，因你的网站浏览和服务器配置 而异。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/" data-id="cjpi4wo0p003uf9cpkorqqfj7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-09-09-Nginx性能优化之Buffers" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/" class="article-date">
  <time datetime="2018-09-08T16:00:00.000Z" itemprop="datePublished">2018-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/">Nginx性能优化之Buffers</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h2><h3 id="client-body-buffer-size"><a href="#client-body-buffer-size" class="headerlink" title="client_body_buffer_size"></a><code>client_body_buffer_size</code></h3><p>设置读取客户端请求正文的缓冲区大小。如果请求主体大于缓冲区，则整个主体或仅其部分被写入临时文件。对 <code>client_body_buffer_size</code> 而言，设置 16k 大小在大多数情况下是足够的。</p>
<p>这是又一个可以产生巨大影响的设置，必须谨慎使用。太小了，则 nginx 会不断地使用 I/O 把剩余的部分写入文件。太大了，则当攻击者可以打开所有连接但你无法在系统上分配足够缓冲来处理这些连接时，你可能容易受到 DOS 攻击。</p>
<h3 id="client-header-buffer-size-和-large-client-header-buffers"><a href="#client-header-buffer-size-和-large-client-header-buffers" class="headerlink" title="client_header_buffer_size 和 large_client_header_buffers"></a><code>client_header_buffer_size</code> 和 <code>large_client_header_buffers</code></h3><p>如果 header 不能跟 <code>client_header_buffer_size</code> 匹配上，就会使用 <code>large_client_header_buffers</code>。如果请求也不适合 <code>large_client_header_buffers</code>，将给客户端返回一个错误提示。对于大多数的请求来说，1KB 的缓存是足够的。但是，如果一个包含大量记录的请求，1KB 是不够的。</p>
<p>如果请求行的长度超限，将给客户端返回一个 414（请求的 URI 太长）错误提示。如果请求的 header 长度超限，将抛出一个 400（错误请求）的错误代码</p>
<h3 id="client-max-body-size"><a href="#client-max-body-size" class="headerlink" title="client_max_body_size"></a><code>client_max_body_size</code></h3><p>设置客户端请求主体的最大允许范围，在请求头字段中指定“内容长度”。如果您希望允许用户上传文件，调整此配置以满足您的需要。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Context:	http, server</span><br><span class="line">client_body_buffer_size       16K;</span><br><span class="line">client_header_buffer_size     1k;</span><br><span class="line">large_client_header_buffers   4 8k;</span><br><span class="line">client_max_body_size          8m;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/" data-id="cjpi4wo0o003sf9cpou0s2m8n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-09-04-Nginx性能优化之超时" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/" class="article-date">
  <time datetime="2018-09-03T16:00:00.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/">Nginx性能优化之超时</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p><code>client_body_timeout</code> 和 <code>client_header_timeout</code> 定义了 nginx 在抛出 408（请求超时）错误之前应该等待客户端传输主体或头信息的时间。</p>
<p><code>send_timeout</code> 设置向客户端发送响应的超时时间。超时仅在两次连续的写入操作之间被设置，而不是用于整个响应的传输过程。如果客户端在给定时间内没有收到任何内容，则连接将被关闭。</p>
<p>设置这些值时要小心，因为等待时间过长会使你容易受到攻击者的攻击，并且等待时间太短的话会切断与速度较慢的客户端的连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Configure timeouts</span><br><span class="line">client_body_timeout   12;</span><br><span class="line">client_header_timeout 12;</span><br><span class="line">send_timeout          10;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/" data-id="cjpi4wo0r0040f9cpuzpbkvew" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-08-30-Nginx性能优化之缓存" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/nginx/2018-08-30-Nginx性能优化之缓存/" class="article-date">
  <time datetime="2018-08-29T16:00:00.000Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/30/nginx/2018-08-30-Nginx性能优化之缓存/">Nginx性能优化之缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>http缓存原理具体见<a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a></p>
<p>管理缓存可以仅由 2 个 header 控制：</p>
<ul>
<li>在 HTTP/1.1 中用 Cache-Control 管理缓存</li>
<li>Pragma 对于 HTTP/1.0 客户端的向后兼容性</li>
</ul>
<p>缓存本身可以分为两类：公共缓存和私有缓存。公共缓存是被多个用户共同使用的。专用缓存专用于单个用户。我们可以很容易地区分，应该使用哪种缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_header Cache-Control public;</span><br><span class="line">add_header Pragma public;</span><br></pre></td></tr></table></figure></p>
<h2 id="Nginx实现缓存"><a href="#Nginx实现缓存" class="headerlink" title="Nginx实现缓存"></a>Nginx实现缓存</h2><p>Nginx实现缓存非常简单，只需在Location和if块中加入<code>expires TIME;</code>即可，<a href="http://nginx.org/en/docs/http/ngx_http_headers_module.html#expires" target="_blank" rel="noopener">详见官方文档</a></p>
<h2 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h2><p>TIME可以写多种单位</p>
<ul>
<li>ms    milliseconds</li>
<li>s        seconds</li>
<li>m        minutes</li>
<li>h        hours</li>
<li>d        days</li>
<li>w        weeks</li>
<li>M        months, 30 days</li>
<li>y        years, 365 days</li>
</ul>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><h3 id="Nginx配置："><a href="#Nginx配置：" class="headerlink" title="Nginx配置："></a>Nginx配置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.test.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/test.com;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.(jpg|jpeg|png|gif|ico)$  &#123;</span><br><span class="line">        expires 1w;</span><br><span class="line">        add_header Cache-Control public;</span><br><span class="line">        add_header Pragma public;</span><br><span class="line">        root /var/www/test.com/images；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-var-www-test-com-创建-index-html"><a href="#在-var-www-test-com-创建-index-html" class="headerlink" title="在 /var/www/test.com 创建 index.html"></a>在 /var/www/test.com 创建 index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Nginx expires demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/lady.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在-var-www-test-com-images-下添加-lady-jpg"><a href="#在-var-www-test-com-images-下添加-lady-jpg" class="headerlink" title="在 /var/www/test.com/images 下添加 lady.jpg"></a>在 /var/www/test.com/images 下添加 lady.jpg</h3><p>连续两次用chrome访问192.168.1.36，发现第二次多了如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status Code: 200 OK (from memory cache)</span><br></pre></td></tr></table></figure></p>
<p>说明已经使用强制缓存，直接从内存中读取图片了。</p>
<p>上面的配置似乎足够了。然而，使用公共缓存时有一个注意事项。</p>
<p>让我们看看如果将我们的资源存储在公共缓存（如 CDN）中，URI 将是唯一的标识符。在这种情况下，我们认为 gzip 是开启的。</p>
<p>有2个浏览器：</p>
<ul>
<li>旧的，不支持 gzip</li>
<li>新的，支持 gzip</li>
</ul>
<p>旧的浏览器给 CDN 发送了一个 netguru.co/style 请求。但是 CDN 也没有这个资源，它将会给我们的服务器发送请求，并且返回未经压缩的响应。CDN 在哈希里存储文件（为以后使用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  netguru.co/styles.css =&gt; FILE(&quot;/sites/netguru/style.css&quot;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后将其返回给客户端。</p>
<p>现在，新的浏览器发送相同的请求到 CDN，请求 netguru.co/style.css，获取 gzip 打包的资源。由于 CDN 仅通过 URI 标识资源，它将为新浏览器返回一样的未压缩资源。新的浏览器将尝试提取未打包的文件，但是将获得无用的东西。</p>
<p>如果我们能够告诉公共缓存是怎样进行 URI 和编码的资源识别，我们就可以避免这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  (netguru.co/styles.css, gzip) =&gt; FILE(&quot;/sites/netguru/style.css.gzip&quot;)</span><br><span class="line">  (netguru.co/styles.css, text/css) =&gt; FILE(&quot;/sites/netguru/style.css&quot;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">``</span><br></pre></td></tr></table></figure></p>
<p>这正是 Vary Accept-Encoding: 完成的。它告诉公共缓存，可以通过 URI 和 Accept-Encoding header 区分资源。</p>
<p>所以我们的最终配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">  expires 1M;</span><br><span class="line">  add_header Cache-Control public;</span><br><span class="line">  add_header Pragma public;</span><br><span class="line">  add_header Vary Accept-Encoding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/30/nginx/2018-08-30-Nginx性能优化之缓存/" data-id="cjpi4wo0t0042f9cp08eukykp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-08-28-Nginx性能优化之压缩gzip" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/nginx/2018-08-28-Nginx性能优化之压缩gzip/" class="article-date">
  <time datetime="2018-08-27T16:00:00.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/nginx/2018-08-28-Nginx性能优化之压缩gzip/">Nginx性能优化之压缩gzip</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="优化网络传输速度"><a href="#优化网络传输速度" class="headerlink" title="优化网络传输速度"></a>优化网络传输速度</h2><p>一般浏览器的请求头会有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br></pre></td></tr></table></figure></p>
<p>这代表浏览器接受这些压缩格式的数据</p>
<p>服务器可以根据这个头来进行压缩响应数据，在响应头添加如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding:gzip</span><br><span class="line">Content-Length:36093</span><br></pre></td></tr></table></figure></p>
<h2 id="Gzip"><a href="#Gzip" class="headerlink" title="Gzip"></a>Gzip</h2><p>启用 gzip 可以显著降低响应的（报文）大小，因此，客户端（网页）会显得更快些。</p>
<h2 id="压缩级别"><a href="#压缩级别" class="headerlink" title="压缩级别"></a>压缩级别</h2><p>Gzip 有不同的压缩级别，1 到 9 级。递增这个级别将会减少文件的大小，但也会增加资源消耗。作为标准我们将这个数字（级别）保持在 3 - 5 级，就像上面说的那样，它将会得到较小的节省，同时也会得到更大的 CPU 使用率。</p>
<p>这有个通过 gzip 的不同的压缩级别压缩文件的例子，0 代表未压缩文件。</p>
<h2 id="Ngin压缩"><a href="#Ngin压缩" class="headerlink" title="Ngin压缩"></a>Ngin压缩</h2><p>Nginx可以使用gzip来压缩服务器的响应数据，来减少响应数据传输的大小。详见<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">文档</a></p>
<h2 id="gzip配置的常用参数"><a href="#gzip配置的常用参数" class="headerlink" title="gzip配置的常用参数"></a>gzip配置的常用参数</h2><ul>
<li>gzip on|off;  #是否开启gzip</li>
<li>gzip_buffers 32 4K| 16 8K;  #缓冲(压缩在内存中缓冲几块? 每块多大?)</li>
<li>gzip_comp_level [1-9]; #推荐5 压缩级别(级别越高,压的越小,越浪费CPU计算资源)</li>
<li>gzip_disable; #正则匹配UA 什么样的Uri不进行gzip</li>
<li>gzip_min_length 200; # 开始压缩的最小长度(再小就不要压缩了,意义不在)</li>
<li>gzip_http_version 1.0|1.1; # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)</li>
<li>gzip_proxied;  # 设置请求者代理服务器,该如何缓存内容</li>
<li>gzip_types text/plain  application/xml; # 对哪些类型的文件用压缩 如txt,xml,html ,css</li>
<li>gzip_vary on|off;  # 是否传输gzip压缩标志</li>
</ul>
<h2 id="gzip-http-version-1-1"><a href="#gzip-http-version-1-1" class="headerlink" title="gzip_http_version 1.1;"></a>gzip_http_version 1.1;</h2><p>这条指令告诉 nginx 仅在 HTTP 1.1 以上的版本才能使用 gzip。我们在这里不涉及 HTTP 1.0，至于 HTTP 1.0 版本，它是不可能既使用 keep-alive 和 gzip 的。因此你必须做出决定：使用 HTTP 1.0 的客户端要么错过 gzip，要么错过 keep-alive。</p>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    gzip on;               # enable gzip</span><br><span class="line">    gzip_http_version 1.1; # turn on gzip for http 1.1 and above</span><br><span class="line">    gzip_disable &quot;msie6&quot;;  # IE 6 had issues with gzip</span><br><span class="line">    gzip_comp_level 5;     # inc compresion level, and CPU usage</span><br><span class="line">    gzip_min_length 100;   # minimal weight to gzip file</span><br><span class="line">    gzip_proxied any;      # enable gzip for proxied requests (e.g. CDN)</span><br><span class="line">    gzip_buffers 16 8k;    # compression buffers (if we exceed this value, disk will be used instead of RAM)</span><br><span class="line">    gzip_vary on;          # add header Vary Accept-Encoding (more on that in Caching section)</span><br><span class="line"></span><br><span class="line">    # define files which should be compressed</span><br><span class="line">    gzip_types text/plain;</span><br><span class="line">    gzip_types text/css;</span><br><span class="line">    gzip_types application/javascript;</span><br><span class="line">    gzip_types application/json;</span><br><span class="line">    gzip_types application/vnd.ms-fontobject;</span><br><span class="line">    gzip_types application/x-font-ttf;</span><br><span class="line">    gzip_types font/opentype;</span><br><span class="line">    gzip_types image/svg+xml;</span><br><span class="line">    gzip_types image/x-icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><ul>
<li>图片/mp3这样的二进制文件,不必压缩。<br>因为压缩率比较小, 比如100-&gt;80字节,而且压缩也是耗费CPU资源的.</li>
<li>比较小的文件不必压缩,</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/28/nginx/2018-08-28-Nginx性能优化之压缩gzip/" data-id="cjpi4wo0r003yf9cpq4reibgf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-08-26-Nginx性能优化之进程数配置" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/26/nginx/2018-08-26-Nginx性能优化之进程数配置/" class="article-date">
  <time datetime="2018-08-25T16:00:00.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/26/nginx/2018-08-26-Nginx性能优化之进程数配置/">Nginx性能优化之进程数配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="我应该使用多少进程？"><a href="#我应该使用多少进程？" class="headerlink" title="我应该使用多少进程？"></a>我应该使用多少进程？</h1><h2 id="工作进程"><a href="#工作进程" class="headerlink" title="工作进程"></a>工作进程</h2><p>worker_process 指令会指定：应该运行多少个 worker。默认情况下，此值设置为 1。最安全的设置是通过传递 auto 选项来使用核心数量。</p>
<p>但由于 Nginx 的架构，其处理请求的速度非常快 - 我们可能一次不会使用超过 2-4 个进程（除非你正在托管 Facebook 或在 nginx 内部执行一些 CPU 密集型的任务）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_process auto;</span><br></pre></td></tr></table></figure></p>
<h2 id="worker-连接"><a href="#worker-连接" class="headerlink" title="worker 连接"></a>worker 连接</h2><p>与 worker_process 直接绑定的指令是 worker_connections。它指定一个工作进程可以一次打开多少个连接。这个数目包括所有连接（例如与代理服务器的连接），而不仅仅是与客户端的连接。此外，值得记住的是，一个客户端可以打开多个连接，同时获取其他资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_connections 4096;</span><br></pre></td></tr></table></figure></p>
<h2 id="打开文件数目限制"><a href="#打开文件数目限制" class="headerlink" title="打开文件数目限制"></a>打开文件数目限制</h2><p>在基于 Unix 系统中的“一切都是文件”。这意味着文档、目录、管道甚至套接字都是文件。系统对一个进程可以打开多少文件有一个限制。要查看该限制：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -Sn      <span class="comment"># soft limit</span></span><br><span class="line"><span class="built_in">ulimit</span> -Sn      <span class="comment"># hard limit</span></span><br></pre></td></tr></table></figure></p>
<p>这个系统限制必须根据 worker_connections 进行调整。任何传入的连接都会打开至少一个文件（通常是两个连接套接字以及后端连接套接字或磁盘上的静态文件）。所以这个值等于 worker_connections*2 是安全的。幸运的是，Nginx 提供了一个配置选项来增加这个系统的值。要使用这个配置，请添加具有适当数目的 worker_rlimit_nofile 指令并重新加载 nginx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 8192;</span><br></pre></td></tr></table></figure></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker_process auto;</span><br><span class="line">worker_connections 4096;   # Sets the maximum number of simultaneous connections that can be opened by a worker process.</span><br><span class="line">worker_rlimit_nofile 8192; # Changes the limit on the maximum number of open files (RLIMIT_NOFILE) for worker processes.</span><br></pre></td></tr></table></figure>
<h2 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h2><p>如上所述，我们可以计算一次可以处理多少个并发连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最大连接数 = </span><br><span class="line"></span><br><span class="line">    worker_processes * worker_connections</span><br><span class="line">----------------------------------------------</span><br><span class="line"> (keep_alive_timeout + avg_response_time) * 2</span><br></pre></td></tr></table></figure></p>
<p>keep_alive_timeout (后续有更多介绍) + avg_response_time 告诉我们：单个连接持续了多久。我们也除以 2，通常情况下，你将有一个客户端打开 2 个连接的情况：一个在 nginx 和客户端之间，另一个在 nginx 和上游服务器之间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/26/nginx/2018-08-26-Nginx性能优化之进程数配置/" data-id="cjpi4wo0m003of9cpfrb6nqa0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-08-24-Nginx性能优化之tcp一次性发送" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/24/nginx/2018-08-24-Nginx性能优化之tcp一次性发送/" class="article-date">
  <time datetime="2018-08-23T16:00:00.000Z" itemprop="datePublished">2018-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/nginx/2018-08-24-Nginx性能优化之tcp一次性发送/">Nginx性能优化之tcp一次性发送</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h2><p><code>tcp_nopush</code> 与 <code>tcp_nodelay</code> 相反。不是为了尽可能快地推送数据包，它的目标是一次性优化数据的发送量。</p>
<p>在发送给客户端之前，它将强制等待包达到最大长度(MSS)。</p>
<ul>
<li>而且这个指令只有在 <code>sendfile</code> 开启时才起作用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendfile on;</span><br><span class="line">tcp_nopush on;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看起来 tcp_nopush 和 tcp_nodelay 是互斥的。但是，如果所有 3 个指令都开启了，nginx 会：</p>
<ul>
<li>确保数据包在发送给客户之前是已满的</li>
<li>对于最后一个数据包，tcp_nopush 将被删除 —— 允许 TCP 立即发送，没有 200ms 的延迟</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/24/nginx/2018-08-24-Nginx性能优化之tcp一次性发送/" data-id="cjpi4wo0n003qf9cpfrbokzoj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx/2018-08-22-Nginx性能优化之文件发送" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/22/nginx/2018-08-22-Nginx性能优化之文件发送/" class="article-date">
  <time datetime="2018-08-21T16:00:00.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/22/nginx/2018-08-22-Nginx性能优化之文件发送/">Nginx性能优化之文件发送</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>正常来说，当要发送一个文件时需要下面的步骤：</p>
<ol>
<li>malloc(3) - 分配一个本地缓冲区，储存对象数据。</li>
<li>read(2) - 检索和复制对象到本地缓冲区。</li>
<li>write(2) - 从本地缓冲区复制对象到 socket 缓冲区。</li>
</ol>
<p>这涉及到两个上下文切换（读，写），并使相同对象的第二个副本成为不必要的。正如你所看到的，这不是最佳的方式。值得庆幸的是还有另一个系统调用，提升了发送文件（的效率），它被称为：sendfile(2)（想不到吧！居然是这名字）。这个调用在文件 cache 中检索一个对象，并传递指针（不需要复制整个对象），直接传递到 socket 描述符，Netflix 表示，使用 sendfile(2) 将网络吞吐量从 6Gbps 提高到了 30Gbps。</p>
<p>然而，sendfile(2) 有一些注意事项：</p>
<ul>
<li>不可用于 UNIX sockets（例如：当通过你的上游服务器发送静态文件时）</li>
<li>能否执行不同的操作，取决于操作系统（这里查看更多）</li>
</ul>
<p>在 nginx 中打开它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile on;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yacen.github.io/2018/08/22/nginx/2018-08-22-Nginx性能优化之文件发送/" data-id="cjpi4wo0m003mf9cpyofyrb5z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/egg/">egg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs-yaml/">nodejs yaml</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/request/">request</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lodash/">lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/koa/" style="font-size: 15px;">koa</a> <a href="/tags/lodash/" style="font-size: 20px;">lodash</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/28/egg/egg-特性/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/20/nginx/2018-09-20-Nginx错误之13Permission denied/">Nginx错误之13:Permission denied</a>
          </li>
        
          <li>
            <a href="/2018/09/12/nginx/2018-09-12-Nginx性能优化之Keep-Alive/">Nginx性能优化之Keep-Alive</a>
          </li>
        
          <li>
            <a href="/2018/09/09/nginx/2018-09-09-Nginx性能优化之Buffers/">Nginx性能优化之Buffers</a>
          </li>
        
          <li>
            <a href="/2018/09/04/nginx/2018-09-04-Nginx性能优化之超时/">Nginx性能优化之超时</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Jax<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>